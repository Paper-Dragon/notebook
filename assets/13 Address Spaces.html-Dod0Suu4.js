import{ah as a,ai as r,aj as e,ap as o,am as n}from"./app-BkSkIdiS.js";const s="/assets/address_space-BTs5TK3H.png",l="/assets/address_space_example-CdWNgp79.png",p={};function i(c,t){return n(),r("div",null,t[0]||(t[0]=[e("h1",{id:"_13-抽象-地址空间",tabindex:"-1"},[e("a",{class:"header-anchor",href:"#_13-抽象-地址空间"},[e("span",null,"13 抽象:地址空间")])],-1),e("p",null,[e("strong",null,"概述:"),e("br"),o(" 内存memory可以看作是一个长长的数组(i.e.,4GB,8GB或更多),为了让每个进程都有自己独立的内存空间.操作系统给每个进程都分配了物理内存空间,但只提供给进程虚拟地址,用户能看到的都是虚拟地址,至于虚拟地址和真实物理地址的映射则由操作系统完成,这部分对用户是透明的,用户其实也不用关心简单的分配方式如下图所示,可以看出物理层面,内存都隔离开了. "),e("img",{src:s,alt:""})],-1),e("ol",null,[e("li",null,[e("strong",null,"地址空间"),e("br"),o(" 地址空间包含运行的程序的所有内存状态.包括程序代码,堆,栈.代码是静态的,不会动态增加会减少,直接放在最上面.堆和栈会动态变化,放在上面和下面,可以往中间动态增加.栈用来保存当前的函数调用信息,局部变量,方法参数和返回值.堆用于动态分配的,用户管理的内存.比如c语言的molloc()或Java的new 对象创建等. "),e("img",{src:l,alt:""})])],-1)]))}const d=a(p,[["render",i]]),g=JSON.parse('{"path":"/ostep-note/1%20virtualization/13%20Address%20Spaces.html","title":"13 抽象:地址空间","lang":"zh-CN","frontmatter":{"description":"13 抽象:地址空间 概述: 内存memory可以看作是一个长长的数组(i.e.,4GB,8GB或更多),为了让每个进程都有自己独立的内存空间.操作系统给每个进程都分配了物理内存空间,但只提供给进程虚拟地址,用户能看到的都是虚拟地址,至于虚拟地址和真实物理地址的映射则由操作系统完成,这部分对用户是透明的,用户其实也不用关心简单的分配方式如下图所示,可以...","head":[["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"13 抽象:地址空间\\",\\"image\\":[\\"\\"],\\"dateModified\\":null,\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"Paper-Dragon\\",\\"url\\":\\"https://github.com/Paper-Dragon\\",\\"email\\":\\"2678885646@qq.com\\"}]}"],["meta",{"property":"og:url","content":"https://www.geekery.cn/ostep-note/1%20virtualization/13%20Address%20Spaces.html"}],["meta",{"property":"og:site_name","content":"运维开发绿皮书"}],["meta",{"property":"og:title","content":"13 抽象:地址空间"}],["meta",{"property":"og:description","content":"13 抽象:地址空间 概述: 内存memory可以看作是一个长长的数组(i.e.,4GB,8GB或更多),为了让每个进程都有自己独立的内存空间.操作系统给每个进程都分配了物理内存空间,但只提供给进程虚拟地址,用户能看到的都是虚拟地址,至于虚拟地址和真实物理地址的映射则由操作系统完成,这部分对用户是透明的,用户其实也不用关心简单的分配方式如下图所示,可以..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}]]},"git":{},"readingTime":{"minutes":1.02,"words":305},"filePathRelative":"ostep-note/1 virtualization/13 Address Spaces.md","excerpt":"\\n<p><strong>概述:</strong><br>\\n内存memory可以看作是一个长长的数组(i.e.,4GB,8GB或更多),为了让每个进程都有自己独立的内存空间.操作系统给每个进程都分配了物理内存空间,但只提供给进程虚拟地址,用户能看到的都是虚拟地址,至于虚拟地址和真实物理地址的映射则由操作系统完成,这部分对用户是透明的,用户其实也不用关心简单的分配方式如下图所示,可以看出物理层面,内存都隔离开了.\\n</p>\\n<ol>\\n<li><strong>地址空间</strong><br>\\n地址空间包含运行的程序的所有内存状态.包括程序代码,堆,栈.代码是静态的,不会动态增加会减少,直接放在最上面.堆和栈会动态变化,放在上面和下面,可以往中间动态增加.栈用来保存当前的函数调用信息,局部变量,方法参数和返回值.堆用于动态分配的,用户管理的内存.比如c语言的molloc()或Java的new 对象创建等.\\n</li>\\n</ol>","autoDesc":true}');export{d as comp,g as data};
