import{ah as n,ai as r,ar as o,am as e}from"./app-BfaWCr0R.js";const i={};function s(l,t){return e(),r("div",null,t[0]||(t[0]=[o('<h1 id="_7-调度策略" tabindex="-1"><a class="header-anchor" href="#_7-调度策略"><span>7 调度策略</span></a></h1><p><strong>概述</strong><br> 比较好的调度策略是能优先处理对响应时间要求高的任务,同时不让需要长时间计算的任务饥饿<br> (i.e.,键盘打字就属于对响应时间要求高的任务,拷贝文件就属于需要长时间计算cpu密集的任务)<br> 下面分析几种不同的调度策略,并分析它们的利弊</p><p><strong>概念解释</strong></p><ul><li>周转时间<br> 任务从到来到执行结束时间,可以想象如果任务中途不被打断一直执行,则周转时间短</li><li>响应时间 任务到来到第一次被调度执行的时间</li></ul><ol><li><strong>FIFO</strong><br> First in First out 先进先出策略,有点是简单,但也只是简单,缺点很明显,任务的周转时间和响应时间都很差,假设cpu计算时间长的任务先到,则其它任务就只能干等了,非常不友好</li><li><strong>SJF</strong><br> Shortest Job First 最短任务优先策略, 前提是知道任务的执行时间,然后任务同时到来的时候,优先执行需要时间短的任务 缺点:先不说现实情况下,基本不可能一开始就知道任务的执行时间. 当大任务先到时,也不可避免其它任务等待</li><li><strong>STCF</strong><br> Shortest Time-to-Completion First 最短完成时间优先策略,前提是知道任务的执行时间长短,让任务的执行时间比当前任务短,则切换到该任务执行,这种方法优化了任务的平均周转时间,缺点是容易引起任务饥饿,假设一直都有短任务到来,则长任务就会得不到执行,引发饥饿</li><li><strong>RR</strong><br> Round Robin 轮转策略,不管什么任务,都每隔一段时间轮流执行,可优化任务的响应时间,缺点很明显,任务的平均周转时间很糟糕,同时进程的切换比较频繁,切换的消耗也比较大</li></ol>',5)]))}const p=n(i,[["render",s]]),c=JSON.parse('{"path":"/ostep-note/1%20virtualization/7%20CPU%20Scheduling.html","title":"7 调度策略","lang":"zh-CN","frontmatter":{"description":"7 调度策略 概述 比较好的调度策略是能优先处理对响应时间要求高的任务,同时不让需要长时间计算的任务饥饿 (i.e.,键盘打字就属于对响应时间要求高的任务,拷贝文件就属于需要长时间计算cpu密集的任务) 下面分析几种不同的调度策略,并分析它们的利弊 概念解释 周转时间 任务从到来到执行结束时间,可以想象如果任务中途不被打断一直执行,则周转时间短 响应时...","head":[["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"7 调度策略\\",\\"image\\":[\\"\\"],\\"dateModified\\":null,\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"Paper-Dragon\\",\\"url\\":\\"https://github.com/Paper-Dragon\\",\\"email\\":\\"2678885646@qq.com\\"}]}"],["meta",{"property":"og:url","content":"https://www.geekery.cn/ostep-note/1%20virtualization/7%20CPU%20Scheduling.html"}],["meta",{"property":"og:site_name","content":"运维开发绿皮书"}],["meta",{"property":"og:title","content":"7 调度策略"}],["meta",{"property":"og:description","content":"7 调度策略 概述 比较好的调度策略是能优先处理对响应时间要求高的任务,同时不让需要长时间计算的任务饥饿 (i.e.,键盘打字就属于对响应时间要求高的任务,拷贝文件就属于需要长时间计算cpu密集的任务) 下面分析几种不同的调度策略,并分析它们的利弊 概念解释 周转时间 任务从到来到执行结束时间,可以想象如果任务中途不被打断一直执行,则周转时间短 响应时..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}]]},"git":{},"readingTime":{"minutes":1.73,"words":518},"filePathRelative":"ostep-note/1 virtualization/7 CPU Scheduling.md","excerpt":"\\n<p><strong>概述</strong><br>\\n比较好的调度策略是能优先处理对响应时间要求高的任务,同时不让需要长时间计算的任务饥饿<br>\\n(i.e.,键盘打字就属于对响应时间要求高的任务,拷贝文件就属于需要长时间计算cpu密集的任务)<br>\\n下面分析几种不同的调度策略,并分析它们的利弊</p>\\n<p><strong>概念解释</strong></p>\\n<ul>\\n<li>周转时间<br>\\n任务从到来到执行结束时间,可以想象如果任务中途不被打断一直执行,则周转时间短</li>\\n<li>响应时间\\n任务到来到第一次被调度执行的时间</li>\\n</ul>\\n<ol>\\n<li><strong>FIFO</strong><br>\\nFirst in First out 先进先出策略,有点是简单,但也只是简单,缺点很明显,任务的周转时间和响应时间都很差,假设cpu计算时间长的任务先到,则其它任务就只能干等了,非常不友好</li>\\n<li><strong>SJF</strong><br>\\nShortest Job First 最短任务优先策略, 前提是知道任务的执行时间,然后任务同时到来的时候,优先执行需要时间短的任务\\n缺点:先不说现实情况下,基本不可能一开始就知道任务的执行时间. 当大任务先到时,也不可避免其它任务等待</li>\\n<li><strong>STCF</strong><br>\\nShortest Time-to-Completion First 最短完成时间优先策略,前提是知道任务的执行时间长短,让任务的执行时间比当前任务短,则切换到该任务执行,这种方法优化了任务的平均周转时间,缺点是容易引起任务饥饿,假设一直都有短任务到来,则长任务就会得不到执行,引发饥饿</li>\\n<li><strong>RR</strong><br>\\nRound Robin 轮转策略,不管什么任务,都每隔一段时间轮流执行,可优化任务的响应时间,缺点很明显,任务的平均周转时间很糟糕,同时进程的切换比较频繁,切换的消耗也比较大</li>\\n</ol>","autoDesc":true}');export{p as comp,c as data};
