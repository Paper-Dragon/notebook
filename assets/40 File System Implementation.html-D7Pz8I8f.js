import{ah as n,ai as t,an as o,am as i}from"./app-DXuLkmmU.js";const r="/assets/simple_file_system-Bt0Ceeas.png",s="/assets/inode_model-hU4Wz4oe.png",a="/assets/inode_info-BuXM5P7x.png",l="/assets/file_read_timeline-Dmt3cJQ7.png",p="/assets/file_write_timeline-B0xbLvOe.png",m={};function d(c,e){return i(),t("div",null,e[0]||(e[0]=[o('<h1 id="_40-file-system-implementation-文件系统实现" tabindex="-1"><a class="header-anchor" href="#_40-file-system-implementation-文件系统实现"><span>40 File System Implementation 文件系统实现</span></a></h1><p><strong>概述:</strong><br> 这一章主要介绍文件系统是通过什么组织形式,数据结构来管理文件的.</p><ol><li><p><strong>简单的文件系统模型</strong><br> 简单的文件系统模型如下图所示:<br><img src="'+r+'" alt=""><br> 首先可以想到的是,文件系统必须要有存储数据的地方,即上图的数据区域.为了方便管理,文件系统把存储空间分为定长的块block(为了简单,假设统一成4kb大小),文件都由这些块构成.有了这些块当然也得有管理这些块的地方,即上图的inodes区域.inodes区域占用了几个块(上图是5个).每个inode是定长(假设统一为256byte)的数据结构,负责管理一个文件的信息,包括包含多少个块,具体是哪些块,最近访问时间等信息.<br> 在给新文件分配inode和数据块时,需要知道空闲的inode和数据块信息,所以也需要有地方来记录inode和数据块block的分配情况.上图的inodes旁边的i和d数据块则分别用来标记inode和数据库的分配情况.它们都是用bitmap位图结构来标记,每一个位用于指示相应对象/块是否被分配,1表示分配.<br> 最前面的S超级块用来记录文件系统的元数据,包括有多少个inode和block,inodes的起始位置等.</p></li><li><p><strong>文件组织inode</strong><br> inode负责管理详细的文件信息.inode的存储方式的概念图如下:<br><img src="'+s+'" alt="">,每一个inode都有一个编号按顺序排列.因为inode是定长的所以根据inode编号可以很容易计算除inode的具体物理地址.<br> inode主要管理类似下面的信息:<br><img src="'+a+'" alt=""> 其中最主要的就是block的指针信息,它表示构成文件的具体块的位置信息.通过它我们才能定位到真实的block.</p></li><li><p><strong>文件的读写</strong></p><ul><li><strong>读文件</strong><br> 读文件要经历两个步骤open和read.open打开文件的意思是根据文件路径先找到文件的inode,步骤是从根目录逐层读取文件的上层目录信息直到最终找到inode文件.读取下一个目录的步骤一般分为两步,首先在当前目录的数据块找到该目录的目录名与inode的映射,然后读取该目录的inode.<br> 找到文件inode后就可以开始read了,读取每一个块会现在inode里查询该块的位置然后再读取,读取完成后还要更新inode的最新访问时间.<br> 读取/foo/bar文件3个块的流程图如下:<br><img src="'+l+'" alt=""></li><li><strong>写文件</strong><br> 写入文件的步骤要比读取文件的步骤多一些,因为涉及到块的分配.除了打开文件的操作,在写入新块时,会更新块位图标记使用了哪个块,还会更新inode的块位置信息.<br> 创建一个/foo/bar文件并写入3个块数据的流程类似下图:<br><img src="'+p+'" alt=""></li></ul></li><li><p><strong>文件系统的缓存</strong> 在上面介绍的文件读写过程中,文件的打开操作以及文件inode的更新操作都比较多,而这些数据都是存放在磁盘里的,因此会引发很多IO操作.为了避免过多的IO,提高性能,自然想到将数据缓存.现代系统通常将文件系统常用的块缓存,将写入缓冲若干秒.从而可批量写入减少IO次数.</p></li></ol>',3)]))}const g=n(m,[["render",d]]),y=JSON.parse('{"path":"/note-book/OperaSystems/OperatingSystemPrinciple/ostep-note/3persistent/40%20File%20System%20Implementation.html","title":"40 File System Implementation 文件系统实现","lang":"zh-CN","frontmatter":{"description":"40 File System Implementation 文件系统实现 概述: 这一章主要介绍文件系统是通过什么组织形式,数据结构来管理文件的. 简单的文件系统模型 简单的文件系统模型如下图所示: 首先可以想到的是,文件系统必须要有存储数据的地方,即上图的数据区域.为了方便管理,文件系统把存储空间分为定长的块block(为了简单,假设统一成4kb大小...","head":[["meta",{"property":"og:url","content":"https://www.geekery.cn/note-book/OperaSystems/OperatingSystemPrinciple/ostep-note/3persistent/40%20File%20System%20Implementation.html"}],["meta",{"property":"og:site_name","content":"运维开发绿皮书"}],["meta",{"property":"og:title","content":"40 File System Implementation 文件系统实现"}],["meta",{"property":"og:description","content":"40 File System Implementation 文件系统实现 概述: 这一章主要介绍文件系统是通过什么组织形式,数据结构来管理文件的. 简单的文件系统模型 简单的文件系统模型如下图所示: 首先可以想到的是,文件系统必须要有存储数据的地方,即上图的数据区域.为了方便管理,文件系统把存储空间分为定长的块block(为了简单,假设统一成4kb大小..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2024-09-12T17:44:20.000Z"}],["meta",{"property":"article:modified_time","content":"2024-09-12T17:44:20.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"40 File System Implementation 文件系统实现\\",\\"image\\":[\\"\\"],\\"dateModified\\":\\"2024-09-12T17:44:20.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"PaperDragon\\",\\"url\\":\\"https://github.com/Paper-Dragon\\",\\"email\\":\\"2678885646@qq.com\\"}]}"]]},"git":{"createdTime":1691939318000,"updatedTime":1726163060000,"contributors":[{"name":"PaperDragon","username":"PaperDragon","email":"2678885646@qq.com","commits":1,"url":"https://github.com/PaperDragon"},{"name":"Paper-Dragon","username":"Paper-Dragon","email":"2678885646@qq.com","commits":1,"url":"https://github.com/Paper-Dragon"}]},"readingTime":{"minutes":3.15,"words":944},"filePathRelative":"note-book/OperaSystems/OperatingSystemPrinciple/ostep-note/3persistent/40 File System Implementation.md","localizedDate":"2023年8月13日","excerpt":"\\n<p><strong>概述:</strong><br>\\n这一章主要介绍文件系统是通过什么组织形式,数据结构来管理文件的.</p>\\n<ol>\\n<li>\\n<p><strong>简单的文件系统模型</strong><br>\\n简单的文件系统模型如下图所示:<br>\\n<br>\\n首先可以想到的是,文件系统必须要有存储数据的地方,即上图的数据区域.为了方便管理,文件系统把存储空间分为定长的块block(为了简单,假设统一成4kb大小),文件都由这些块构成.有了这些块当然也得有管理这些块的地方,即上图的inodes区域.inodes区域占用了几个块(上图是5个).每个inode是定长(假设统一为256byte)的数据结构,负责管理一个文件的信息,包括包含多少个块,具体是哪些块,最近访问时间等信息.<br>\\n在给新文件分配inode和数据块时,需要知道空闲的inode和数据块信息,所以也需要有地方来记录inode和数据块block的分配情况.上图的inodes旁边的i和d数据块则分别用来标记inode和数据库的分配情况.它们都是用bitmap位图结构来标记,每一个位用于指示相应对象/块是否被分配,1表示分配.<br>\\n最前面的S超级块用来记录文件系统的元数据,包括有多少个inode和block,inodes的起始位置等.</p>\\n</li>\\n<li>\\n<p><strong>文件组织inode</strong><br>\\ninode负责管理详细的文件信息.inode的存储方式的概念图如下:<br>\\n,每一个inode都有一个编号按顺序排列.因为inode是定长的所以根据inode编号可以很容易计算除inode的具体物理地址.<br>\\ninode主要管理类似下面的信息:<br>\\n\\n其中最主要的就是block的指针信息,它表示构成文件的具体块的位置信息.通过它我们才能定位到真实的block.</p>\\n</li>\\n<li>\\n<p><strong>文件的读写</strong></p>\\n<ul>\\n<li><strong>读文件</strong><br>\\n读文件要经历两个步骤open和read.open打开文件的意思是根据文件路径先找到文件的inode,步骤是从根目录逐层读取文件的上层目录信息直到最终找到inode文件.读取下一个目录的步骤一般分为两步,首先在当前目录的数据块找到该目录的目录名与inode的映射,然后读取该目录的inode.<br>\\n找到文件inode后就可以开始read了,读取每一个块会现在inode里查询该块的位置然后再读取,读取完成后还要更新inode的最新访问时间.<br>\\n读取/foo/bar文件3个块的流程图如下:<br>\\n</li>\\n<li><strong>写文件</strong><br>\\n写入文件的步骤要比读取文件的步骤多一些,因为涉及到块的分配.除了打开文件的操作,在写入新块时,会更新块位图标记使用了哪个块,还会更新inode的块位置信息.<br>\\n创建一个/foo/bar文件并写入3个块数据的流程类似下图:<br>\\n</li>\\n</ul>\\n</li>\\n<li>\\n<p><strong>文件系统的缓存</strong>\\n在上面介绍的文件读写过程中,文件的打开操作以及文件inode的更新操作都比较多,而这些数据都是存放在磁盘里的,因此会引发很多IO操作.为了避免过多的IO,提高性能,自然想到将数据缓存.现代系统通常将文件系统常用的块缓存,将写入缓冲若干秒.从而可批量写入减少IO次数.</p>\\n</li>\\n</ol>","autoDesc":true}');export{g as comp,y as data};
