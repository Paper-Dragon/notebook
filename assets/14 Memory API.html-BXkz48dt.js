import{ah as t,ai as o,an as r,am as n}from"./app-De1gdLa9.js";const l={};function a(i,e){return n(),o("div",null,e[0]||(e[0]=[r('<h1 id="_14-内存操作接口-memory-api" tabindex="-1"><a class="header-anchor" href="#_14-内存操作接口-memory-api"><span>14 内存操作接口 Memory API</span></a></h1><ol><li><p><strong>内存类型</strong></p><ul><li>栈内存<br> 内存的申请和释放由编译器隐式管理,不需要用户操作.当调用函数时,会在栈上开辟空间存储参数,本地变量,返回值,当函数退出时,释放内存.</li><li>堆内存<br> 堆内存的申请和释放需要由编程者显示管理(虽然高级语言Java会帮忙完成),栈内存的作用范围都在函数内,存活时间都比较短.堆的内存作用范围比较大,存活时间比较长.</li></ul></li><li><p><strong>内存申请malloc()调用</strong><br> malloc的函数定义是: void *malloc(size_t size); malloc通过传入字节数申请内存.返回类型为void是为了方便程序员根据需要转换返回类型,比如转换成double,int等</p></li><li><p><strong>内存释放free()调用</strong><br> free(指针),传入free内存指针,则可以释放改指针占用的堆内存</p></li><li><p><strong>常见错误</strong><br> 忘记分配内存,没有分配足够的内存,忘记初始化分配的内存等</p></li></ol>',2)]))}const s=t(l,[["render",a]]),m=JSON.parse('{"path":"/ostep-note/1%20virtualization/14%20Memory%20API.html","title":"14 内存操作接口 Memory API","lang":"zh-CN","frontmatter":{"description":"14 内存操作接口 Memory API 内存类型 栈内存 内存的申请和释放由编译器隐式管理,不需要用户操作.当调用函数时,会在栈上开辟空间存储参数,本地变量,返回值,当函数退出时,释放内存. 堆内存 堆内存的申请和释放需要由编程者显示管理(虽然高级语言Java会帮忙完成),栈内存的作用范围都在函数内,存活时间都比较短.堆的内存作用范围比较大,存活时间...","head":[["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"14 内存操作接口 Memory API\\",\\"image\\":[\\"\\"],\\"dateModified\\":null,\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"Paper-Dragon\\",\\"url\\":\\"https://github.com/Paper-Dragon\\",\\"email\\":\\"2678885646@qq.com\\"}]}"],["meta",{"property":"og:url","content":"https://www.geekery.cn/ostep-note/1%20virtualization/14%20Memory%20API.html"}],["meta",{"property":"og:site_name","content":"运维开发绿皮书"}],["meta",{"property":"og:title","content":"14 内存操作接口 Memory API"}],["meta",{"property":"og:description","content":"14 内存操作接口 Memory API 内存类型 栈内存 内存的申请和释放由编译器隐式管理,不需要用户操作.当调用函数时,会在栈上开辟空间存储参数,本地变量,返回值,当函数退出时,释放内存. 堆内存 堆内存的申请和释放需要由编程者显示管理(虽然高级语言Java会帮忙完成),栈内存的作用范围都在函数内,存活时间都比较短.堆的内存作用范围比较大,存活时间..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}]]},"git":{},"readingTime":{"minutes":0.93,"words":279},"filePathRelative":"ostep-note/1 virtualization/14 Memory API.md","excerpt":"\\n<ol>\\n<li>\\n<p><strong>内存类型</strong></p>\\n<ul>\\n<li>栈内存<br>\\n内存的申请和释放由编译器隐式管理,不需要用户操作.当调用函数时,会在栈上开辟空间存储参数,本地变量,返回值,当函数退出时,释放内存.</li>\\n<li>堆内存<br>\\n堆内存的申请和释放需要由编程者显示管理(虽然高级语言Java会帮忙完成),栈内存的作用范围都在函数内,存活时间都比较短.堆的内存作用范围比较大,存活时间比较长.</li>\\n</ul>\\n</li>\\n<li>\\n<p><strong>内存申请malloc()调用</strong><br>\\nmalloc的函数定义是: void *malloc(size_t size); malloc通过传入字节数申请内存.返回类型为void是为了方便程序员根据需要转换返回类型,比如转换成double,int等</p>\\n</li>\\n<li>\\n<p><strong>内存释放free()调用</strong><br>\\nfree(指针),传入free内存指针,则可以释放改指针占用的堆内存</p>\\n</li>\\n<li>\\n<p><strong>常见错误</strong><br>\\n忘记分配内存,没有分配足够的内存,忘记初始化分配的内存等</p>\\n</li>\\n</ol>","autoDesc":true}');export{s as comp,m as data};
