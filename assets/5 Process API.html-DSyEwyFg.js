import{ah as e,ai as o,ar as r,am as n}from"./app-C9yoftjo.js";const i={};function l(p,t){return n(),o("div",null,t[0]||(t[0]=[r('<h1 id="_5-进程接口" tabindex="-1"><a class="header-anchor" href="#_5-进程接口"><span>5 进程接口</span></a></h1><p><strong>概述</strong><br> 进程的创建是通过底层fork()和exec()系统调用 进程可通过wait()系统调用可以等待其创建的子进程执行完成</p><ol><li><p><strong>fork()系统调用</strong> fork()用于创建进程,当进程调用fork()时,会复制当前进程所有环境条件参数,生成新的进程.他们有同样的环境参数,但是pid(进程id)不同,同时拥有自己的内存空间</p></li><li><p><strong>exec()系统调用</strong> fork()调用创建新的进程后,exec()系统调用加载其它程序,覆写代码和静态数据,同时堆,栈和其它内存空间都会重新初始化</p></li><li><p><strong>wait()系统调用</strong> 父进程通过调用wait(),等待其创建的子进程执行完成,然后再运行自己后续操作</p></li><li><p><strong>fork()和exec()的组合</strong> 通过fork()和exec()组合创建新进程运行不同的程序. 通过分离的步骤给予了系统对进程的创建添加操作的可能. 比如通过shell操作时,fork()返回后,通过wait()该进程id,可以等待该进程执行,打印该进程的输出到屏幕. 再比如可以fork()之后可以通过命令改变(ie,wc p3.c &gt; newFile.txt) 重定向输出结果到文件中.</p></li><li><p><strong>其它Api</strong></p><ul><li>kill:向进程发送信号,包括睡眠,终止等</li><li>ps:查看当前运行的进程</li><li>top:当前系统进程的消耗</li></ul></li></ol>',3)]))}const s=e(i,[["render",l]]),c=JSON.parse('{"path":"/ostep-note/1%20virtualization/5%20Process%20API.html","title":"5 进程接口","lang":"zh-CN","frontmatter":{"description":"5 进程接口 概述 进程的创建是通过底层fork()和exec()系统调用 进程可通过wait()系统调用可以等待其创建的子进程执行完成 fork()系统调用 fork()用于创建进程,当进程调用fork()时,会复制当前进程所有环境条件参数,生成新的进程.他们有同样的环境参数,但是pid(进程id)不同,同时拥有自己的内存空间 exec()系统调用 ...","head":[["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"5 进程接口\\",\\"image\\":[\\"\\"],\\"dateModified\\":null,\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"Paper-Dragon\\",\\"url\\":\\"https://github.com/Paper-Dragon\\",\\"email\\":\\"2678885646@qq.com\\"}]}"],["meta",{"property":"og:url","content":"https://www.geekery.cn/ostep-note/1%20virtualization/5%20Process%20API.html"}],["meta",{"property":"og:site_name","content":"运维开发绿皮书"}],["meta",{"property":"og:title","content":"5 进程接口"}],["meta",{"property":"og:description","content":"5 进程接口 概述 进程的创建是通过底层fork()和exec()系统调用 进程可通过wait()系统调用可以等待其创建的子进程执行完成 fork()系统调用 fork()用于创建进程,当进程调用fork()时,会复制当前进程所有环境条件参数,生成新的进程.他们有同样的环境参数,但是pid(进程id)不同,同时拥有自己的内存空间 exec()系统调用 ..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}]]},"git":{},"readingTime":{"minutes":1.25,"words":376},"filePathRelative":"ostep-note/1 virtualization/5 Process API.md","excerpt":"\\n<p><strong>概述</strong><br>\\n进程的创建是通过底层fork()和exec()系统调用\\n进程可通过wait()系统调用可以等待其创建的子进程执行完成</p>\\n<ol>\\n<li>\\n<p><strong>fork()系统调用</strong>\\nfork()用于创建进程,当进程调用fork()时,会复制当前进程所有环境条件参数,生成新的进程.他们有同样的环境参数,但是pid(进程id)不同,同时拥有自己的内存空间</p>\\n</li>\\n<li>\\n<p><strong>exec()系统调用</strong>\\nfork()调用创建新的进程后,exec()系统调用加载其它程序,覆写代码和静态数据,同时堆,栈和其它内存空间都会重新初始化</p>\\n</li>\\n<li>\\n<p><strong>wait()系统调用</strong>\\n父进程通过调用wait(),等待其创建的子进程执行完成,然后再运行自己后续操作</p>\\n</li>\\n<li>\\n<p><strong>fork()和exec()的组合</strong>\\n通过fork()和exec()组合创建新进程运行不同的程序. 通过分离的步骤给予了系统对进程的创建添加操作的可能. 比如通过shell操作时,fork()返回后,通过wait()该进程id,可以等待该进程执行,打印该进程的输出到屏幕. 再比如可以fork()之后可以通过命令改变(ie,wc p3.c &gt; newFile.txt) 重定向输出结果到文件中.</p>\\n</li>\\n<li>\\n<p><strong>其它Api</strong></p>\\n<ul>\\n<li>kill:向进程发送信号,包括睡眠,终止等</li>\\n<li>ps:查看当前运行的进程</li>\\n<li>top:当前系统进程的消耗</li>\\n</ul>\\n</li>\\n</ol>","autoDesc":true}');export{s as comp,c as data};
