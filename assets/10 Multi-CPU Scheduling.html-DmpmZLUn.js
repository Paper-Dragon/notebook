import{aq as e,ar as r,aw as n,av as o}from"./app-zh13eAqJ.js";const p="/assets/cpu_architecture-PpGfymBw.png",c={};function i(a,t){return o(),r("div",null,t[0]||(t[0]=[n('<h1 id="_10-多处理器调度" tabindex="-1"><a class="header-anchor" href="#_10-多处理器调度"><span>10 多处理器调度</span></a></h1><p><strong>概述</strong><br> 当有多个cpu时,进程调度不可避免就会有并发问题出现.目前大概有两种调度策略,一种是单队列调度,一种是多队列调度.二者各有利弊,都有系统采用.</p><p><strong>概念解释</strong></p><ul><li>缓存:<br> 为了加快cpu对内存的访问,每个cpu都有自己的缓存cache,第一次访问内存的数据会拷贝一份到缓存中,第二次访问时直接从缓存中取<br><img src="'+p+'" alt=""></li><li>缓存一致性 假设多个cpu缓存都有同一份数据,某一cpu更改该数据时,更改之前会将其它cpu缓存的该数据缓存置为无效,然后再更新.在硬件层面保证共享内存的唯一性</li></ul><ol><li><p><strong>单队列调度</strong><br> Single-Queue Scheduling 故名思意,把所有需要调度的进程放到同一队列中,优点是简单,可以方便应用现有的调度策略,且方便负载均衡,而不需要做其它工作. 缺点也很明显,缺乏扩展性,因为是单一队列,涉及到并发问题,对代码需要加锁来保证原子性. 加锁是一种非常消耗性能的操作,且随着cpu的个数增加,消耗越大. 还有个缺点是缓存亲和性不友好,进程运行时的数据会存在缓存中,如果因为进程切换,下次切换到另一个cpu执行,因为切换后的cpu缓存里没有原来的数据, 所以会从之前的缓存(没有的从内存)取,这会产生一定的性能消耗</p></li><li><p><strong>多队列调度</strong><br> Multi-Queue MultiProcessor Scheduling 每个cpu都有一个队列管理进程.进程到来时,系统会将任务加入随机或选择空的队列. 跟单队列调度相对应, 优点是可扩展性和缓存亲和性友好.每个cpu都有一个队列所以不会有锁和缓存的问题. 相对应的,缺点就是负载均衡不够友好,可能出现某些cpu的队列任务 执行完的情况下或只有少量进程,而其它队列还有很多进程在执行.虽然可以通过迁移进程到空的队列的方法改善,但同时也会出现并发问题,带来性能消耗</p></li></ol>',5)]))}const u=e(c,[["render",i],["__file","10 Multi-CPU Scheduling.html.vue"]]),s=JSON.parse('{"path":"/note-book/OperaSystems/OperatingSystemPrinciple/ostep-note/1virtualization/10%20Multi-CPU%20Scheduling.html","title":"10 多处理器调度","lang":"zh-CN","frontmatter":{"description":"10 多处理器调度 概述 当有多个cpu时,进程调度不可避免就会有并发问题出现.目前大概有两种调度策略,一种是单队列调度,一种是多队列调度.二者各有利弊,都有系统采用. 概念解释 缓存: 为了加快cpu对内存的访问,每个cpu都有自己的缓存cache,第一次访问内存的数据会拷贝一份到缓存中,第二次访问时直接从缓存中取 缓存一致性 假设多个cpu缓存都有...","head":[["meta",{"property":"og:url","content":"https://www.geekery.cn/note-book/OperaSystems/OperatingSystemPrinciple/ostep-note/1virtualization/10%20Multi-CPU%20Scheduling.html"}],["meta",{"property":"og:site_name","content":"运维开发绿皮书"}],["meta",{"property":"og:title","content":"10 多处理器调度"}],["meta",{"property":"og:description","content":"10 多处理器调度 概述 当有多个cpu时,进程调度不可避免就会有并发问题出现.目前大概有两种调度策略,一种是单队列调度,一种是多队列调度.二者各有利弊,都有系统采用. 概念解释 缓存: 为了加快cpu对内存的访问,每个cpu都有自己的缓存cache,第一次访问内存的数据会拷贝一份到缓存中,第二次访问时直接从缓存中取 缓存一致性 假设多个cpu缓存都有..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2023-08-13T15:08:38.000Z"}],["meta",{"property":"article:modified_time","content":"2023-08-13T15:08:38.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"10 多处理器调度\\",\\"image\\":[\\"\\"],\\"dateModified\\":\\"2023-08-13T15:08:38.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"PaperDragon\\",\\"url\\":\\"https://github.com/Paper-Dragon\\",\\"email\\":\\"2678885646@qq.com\\"}]}"]]},"git":{"createdTime":1691939318000,"updatedTime":1691939318000,"contributors":[{"name":"PaperDragon","username":"PaperDragon","email":"2678885646@qq.com","commits":1,"url":"https://github.com/PaperDragon"}]},"readingTime":{"minutes":2.05,"words":616},"filePathRelative":"note-book/OperaSystems/OperatingSystemPrinciple/ostep-note/1virtualization/10 Multi-CPU Scheduling.md","localizedDate":"2023年8月13日","excerpt":"\\n<p><strong>概述</strong><br>\\n当有多个cpu时,进程调度不可避免就会有并发问题出现.目前大概有两种调度策略,一种是单队列调度,一种是多队列调度.二者各有利弊,都有系统采用.</p>\\n<p><strong>概念解释</strong></p>\\n<ul>\\n<li>缓存:<br>\\n为了加快cpu对内存的访问,每个cpu都有自己的缓存cache,第一次访问内存的数据会拷贝一份到缓存中,第二次访问时直接从缓存中取<br>\\n</li>\\n<li>缓存一致性\\n假设多个cpu缓存都有同一份数据,某一cpu更改该数据时,更改之前会将其它cpu缓存的该数据缓存置为无效,然后再更新.在硬件层面保证共享内存的唯一性</li>\\n</ul>","autoDesc":true}');export{u as comp,s as data};
