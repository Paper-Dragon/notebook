import{ah as t,ai as n,ar as a,am as r}from"./app-Bnthelxf.js";const o="/assets/buddy_system_example-BYbzgbzY.png",l={};function i(p,e){return r(),n("div",null,[...e[0]||(e[0]=[a('<h1 id="_17-free-space-management-空闲空间管理" tabindex="-1"><a class="header-anchor" href="#_17-free-space-management-空闲空间管理"><span>17 Free Space Management 空闲空间管理</span></a></h1><p><strong>概述:</strong><br> 操作系统可通过维护一个空闲列表来管理维护空闲内存空间. 空闲列表相当于一个链表,每一个节点指向空闲空间,并指向下一空闲空间节点.当用户调用 malloc()申请内存时,操作系统根据策略分配空闲空间.分配空间时会按照申请内存大小对分配的空闲空间进行切分,返回申请大小的内存指针,剩余部分 作为新的空闲节点加入空闲列表中</p><ol><li><p><strong>几种分配策略</strong></p><ul><li>最优匹配:匹配大小一样或最接近的节点,实现简单,但是遍历列表比较费时</li><li>最差匹配:返回最大的节点,缺点是遍历费时和容易导致内存碎片</li><li>首次匹配:匹配第一个能满足需求的节点,优点是不需要遍历全部节点,缺点还是会造成内存碎片</li></ul></li><li><p><strong>其它改进内存管理的方法</strong></p><ul><li>分离空闲列表<br> 用一个独立的列表管理经常被申请大小的内存空间.其它大小的分配交给通用的内存分配处理,比如锁和文件系统inode等.独立列表会在系统 启动时初始化,减少了空闲列表初始化的开销,同时分配和销毁操作都比较快,可以提高空闲空间管理性能</li><li>伙伴系统<br> 伙伴系统通过将空闲空间抽象成2^N大小的抽象空间.通过递归将内存一分为二,直到刚好匹配内存申请大小(或大一点).这个系统的优点在于 方便空闲节点的合并.释放空间时,通过检测旁边的空间节点是否空闲,如果空闲则合并为一个大的空闲空间节点<br> 例: <img src="'+o+'" alt=""></li></ul></li></ol>',3)])])}const c=t(l,[["render",i]]),m=JSON.parse('{"path":"/ostep-note/1%20virtualization/17%20Free%20Space%20Management.html","title":"17 Free Space Management 空闲空间管理","lang":"zh-CN","frontmatter":{"description":"17 Free Space Management 空闲空间管理 概述: 操作系统可通过维护一个空闲列表来管理维护空闲内存空间. 空闲列表相当于一个链表,每一个节点指向空闲空间,并指向下一空闲空间节点.当用户调用 malloc()申请内存时,操作系统根据策略分配空闲空间.分配空间时会按照申请内存大小对分配的空闲空间进行切分,返回申请大小的内存指针,剩余部...","head":[["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"17 Free Space Management 空闲空间管理\\",\\"image\\":[\\"\\"],\\"dateModified\\":null,\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"Paper-Dragon\\",\\"url\\":\\"https://github.com/Paper-Dragon\\",\\"email\\":\\"2678885646@qq.com\\"}]}"],["meta",{"property":"og:url","content":"https://www.geekery.cn/ostep-note/1%20virtualization/17%20Free%20Space%20Management.html"}],["meta",{"property":"og:site_name","content":"运维开发绿皮书"}],["meta",{"property":"og:title","content":"17 Free Space Management 空闲空间管理"}],["meta",{"property":"og:description","content":"17 Free Space Management 空闲空间管理 概述: 操作系统可通过维护一个空闲列表来管理维护空闲内存空间. 空闲列表相当于一个链表,每一个节点指向空闲空间,并指向下一空闲空间节点.当用户调用 malloc()申请内存时,操作系统根据策略分配空闲空间.分配空间时会按照申请内存大小对分配的空闲空间进行切分,返回申请大小的内存指针,剩余部..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}]]},"git":{},"readingTime":{"minutes":1.66,"words":497},"filePathRelative":"ostep-note/1 virtualization/17 Free Space Management.md","excerpt":"\\n<p><strong>概述:</strong><br>\\n操作系统可通过维护一个空闲列表来管理维护空闲内存空间. 空闲列表相当于一个链表,每一个节点指向空闲空间,并指向下一空闲空间节点.当用户调用\\nmalloc()申请内存时,操作系统根据策略分配空闲空间.分配空间时会按照申请内存大小对分配的空闲空间进行切分,返回申请大小的内存指针,剩余部分\\n作为新的空闲节点加入空闲列表中</p>\\n<ol>\\n<li>\\n<p><strong>几种分配策略</strong></p>\\n<ul>\\n<li>最优匹配:匹配大小一样或最接近的节点,实现简单,但是遍历列表比较费时</li>\\n<li>最差匹配:返回最大的节点,缺点是遍历费时和容易导致内存碎片</li>\\n<li>首次匹配:匹配第一个能满足需求的节点,优点是不需要遍历全部节点,缺点还是会造成内存碎片</li>\\n</ul>\\n</li>\\n<li>\\n<p><strong>其它改进内存管理的方法</strong></p>\\n<ul>\\n<li>分离空闲列表<br>\\n用一个独立的列表管理经常被申请大小的内存空间.其它大小的分配交给通用的内存分配处理,比如锁和文件系统inode等.独立列表会在系统\\n启动时初始化,减少了空闲列表初始化的开销,同时分配和销毁操作都比较快,可以提高空闲空间管理性能</li>\\n<li>伙伴系统<br>\\n伙伴系统通过将空闲空间抽象成2^N大小的抽象空间.通过递归将内存一分为二,直到刚好匹配内存申请大小(或大一点).这个系统的优点在于\\n方便空闲节点的合并.释放空间时,通过检测旁边的空间节点是否空闲,如果空闲则合并为一个大的空闲空间节点<br>\\n例:\\n</li>\\n</ul>\\n</li>\\n</ol>","autoDesc":true}');export{c as comp,m as data};
