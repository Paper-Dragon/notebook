import{ah as s,ai as a,ar as n,am as e}from"./app-BMcHTqkZ.js";const t="/assets/simple_code_use_select-BJJkQtz0.png",l={};function h(r,i){return e(),a("div",null,i[0]||(i[0]=[n(`<h1 id="_33-event-based-concurrency-基于事件的并发" tabindex="-1"><a class="header-anchor" href="#_33-event-based-concurrency-基于事件的并发"><span>33 Event-based Concurrency 基于事件的并发</span></a></h1><p><strong>概述:</strong><br> 基于线程开发的多线程有两个问题.一是比较容易出错,死锁,阻塞,资源浪费等问题需要特别小心处理;二是多线程的调度是由操作管理的,可能不会按照开发者期望的调度方式运行,因此不能精细控制程序的运行.基于事件并发是一种替代方案.它的思路是等待某些事件发生,然后判断事件类型,使用相应的代码处理.基于事件的并发有一个非常重要的架构:eventLoop().典型的基于事件的服务器的伪代码如下:</p><div class="language-c line-numbers-mode" data-highlighter="shiki" data-ext="c" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">while</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;">1</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">) {</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">    events </span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">=</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;"> getEvents</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">();</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">    for</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> (e in events) </span></span>
<span class="line"><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">        processEvent</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(e);</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>处理逻辑非常简单,无限循环等待某些事件发生.循环处理每个事件.但是具体是如何判断发生的是哪些事件,怎么处理的? 因此需要其它的Api的支持.</p><ol><li><strong>基于事件的重要API:select() (or poll)</strong><br> select()Api是用于接收事件的.它的定义类似如下:<div class="language-c line-numbers-mode" data-highlighter="shiki" data-ext="c" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">int</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;"> select</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">int</span><span style="--shiki-light:#383A42;--shiki-light-font-style:inherit;--shiki-dark:#E06C75;--shiki-dark-font-style:italic;"> nfds</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">,</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">            fd_set </span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">*restrict</span><span style="--shiki-light:#383A42;--shiki-light-font-style:inherit;--shiki-dark:#E06C75;--shiki-dark-font-style:italic;"> readfds</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">,</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">            fd_set </span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">*restrict</span><span style="--shiki-light:#383A42;--shiki-light-font-style:inherit;--shiki-dark:#E06C75;--shiki-dark-font-style:italic;"> writefds</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">,</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">            fd_set </span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">*restrict</span><span style="--shiki-light:#383A42;--shiki-light-font-style:inherit;--shiki-dark:#E06C75;--shiki-dark-font-style:italic;"> errorfds</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">,</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">            struct</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;"> timeval </span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">*restrict</span><span style="--shiki-light:#383A42;--shiki-light-font-style:inherit;--shiki-dark:#E06C75;--shiki-dark-font-style:italic;"> timeout</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">);</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div>nfds代表用户关心的所有文件描述符的最大值,readfds是用户关心读事件(是否可读)的文件描述符集合,writefds则是跟写事件相关的集合,errorfds是跟出错事件相关的集合,timeout是当没有事件发生时等待的超时时间.select返回发生事件的个数,同时readfds,writefds,errorfds内部元素替换为发生相应事件的集合.然后对这些集合做相应的处理.一个简单的使用select()代码:<br><img src="`+t+`" alt=""><br> 从代码看,我们发现没有线程相关的锁,条件变量等,实现也是比较简单易懂的.因为同时只会有一个事件被处理,因此也不需要线程切换,就不会出现之前介绍的线程安全问题.</li><li><strong>基于事件的并发问题</strong><ul><li><strong>阻塞的系统调用</strong><br> 纯粹的基于事件并发是不希望有阻塞发生的.上面的简单实现有一个明显问题就是阻塞的系统调用.往往涉及很多I/O操作,这些操作又会引起进程阻塞.如果阻塞发生意味着不能执行其它操作,导致资源浪费.而基于线程的并发则不会有这个问题.对于这个问题,现在系统有一种异步IO机制(Asynchronous IO) 可以解决这个问题. 它的思路是通过一种数据结构(aiocb)记录IO需要做的事情,用户调用异步IO后马上返回,异步IO根据记录的IO信息,自动执行,并提供接口给用户调用以查看异步IO是否已经完成.<br> aiocb数据结构:<div class="language-c line-numbers-mode" data-highlighter="shiki" data-ext="c" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">struct</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> aiocb {</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">    int</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> aio_fildes;</span><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;"> //File descriptor</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">    off_t</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> aio_offset;</span><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;"> //File offfset</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">    volatile</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> void</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> *</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">aio_buf;</span><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">  //Location of buffer</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">    size_t</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> aio_nbytes;</span><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;"> //Length of transfer</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div>异步读IO接口:<div class="language-c line-numbers-mode" data-highlighter="shiki" data-ext="c" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">int</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;"> aio_read</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">struct</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;"> aiocb </span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">*</span><span style="--shiki-light:#383A42;--shiki-light-font-style:inherit;--shiki-dark:#E06C75;--shiki-dark-font-style:italic;">aiocbp</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">);</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div>查看异步IO是否已经完成接口(mac系统):<div class="language-c line-numbers-mode" data-highlighter="shiki" data-ext="c" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">int</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;"> aio_error</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">const</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> struct</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;"> aiocb </span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">*</span><span style="--shiki-light:#383A42;--shiki-light-font-style:inherit;--shiki-dark:#E06C75;--shiki-dark-font-style:italic;">aiocbp</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">);</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div>虽然通过接口可以查询异步完成情况,但是当IO请求特别多时,调用查询接口还是比较耗费资源的.所以现代系统一般采用信号机制来通知应用IO已经完成.应用接收到中断信号后会停止当前的任务,处理中断.</li><li><strong>状态管理</strong><br> 基于事件的并发还有一个问题就是状态管理问题.因为基于事件并发相当于把基于线程的并发的步骤分为不同的事件,对每类事件进行几种处理.每一种事件处理完后,接下来需要干什么都需要逻辑处理.因此整个声明周期所需要的状态信息都需要管理好.有点类似于送快递.基于线程并发类似于每个人送快递是从开始地送到目的地,开始地和目的地自己都清楚,而基于事件并发,快递是分几段路程送的,每个人送一段路程,如果开始地和目的地不管理好的话,可能送不到最终目的地.</li><li><strong>其它问题</strong><ul><li><strong>多核问题</strong><br> 当机器由单核变为多核时,为了提高效率,可想而知应该并发的处理事件.但是并发处理随之就会带来并发问题,从而不得不使用锁或线程变量.</li><li><strong>系统集成问题</strong><br> 前面介绍过的分页错误,分页交换等问题也可能事件处理过程中出现,势必会导致进程的阻塞,产生资源浪费.</li><li><strong>维护问题</strong><br> 当某些接口由阻塞变为非阻塞时,相应的处理逻辑代码也需要跟着改变.</li><li><strong>接口的易用性问题</strong><br> 虽然异步IO看起来非常有用,但是在应用中使用该接口并不是非常简单.</li></ul></li></ul></li></ol>`,5)]))}const p=s(l,[["render",h]]),d=JSON.parse('{"path":"/ostep-note/2%20%20concurrency/33%20Event-based%20Concurrency.html","title":"33 Event-based Concurrency 基于事件的并发","lang":"zh-CN","frontmatter":{"description":"33 Event-based Concurrency 基于事件的并发 概述: 基于线程开发的多线程有两个问题.一是比较容易出错,死锁,阻塞,资源浪费等问题需要特别小心处理;二是多线程的调度是由操作管理的,可能不会按照开发者期望的调度方式运行,因此不能精细控制程序的运行.基于事件并发是一种替代方案.它的思路是等待某些事件发生,然后判断事件类型,使用相应的...","head":[["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"33 Event-based Concurrency 基于事件的并发\\",\\"image\\":[\\"\\"],\\"dateModified\\":null,\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"Paper-Dragon\\",\\"url\\":\\"https://github.com/Paper-Dragon\\",\\"email\\":\\"2678885646@qq.com\\"}]}"],["meta",{"property":"og:url","content":"https://www.geekery.cn/ostep-note/2%20%20concurrency/33%20Event-based%20Concurrency.html"}],["meta",{"property":"og:site_name","content":"运维开发绿皮书"}],["meta",{"property":"og:title","content":"33 Event-based Concurrency 基于事件的并发"}],["meta",{"property":"og:description","content":"33 Event-based Concurrency 基于事件的并发 概述: 基于线程开发的多线程有两个问题.一是比较容易出错,死锁,阻塞,资源浪费等问题需要特别小心处理;二是多线程的调度是由操作管理的,可能不会按照开发者期望的调度方式运行,因此不能精细控制程序的运行.基于事件并发是一种替代方案.它的思路是等待某些事件发生,然后判断事件类型,使用相应的..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}]]},"git":{},"readingTime":{"minutes":4.35,"words":1305},"filePathRelative":"ostep-note/2  concurrency/33 Event-based Concurrency.md","excerpt":"\\n<p><strong>概述:</strong><br>\\n基于线程开发的多线程有两个问题.一是比较容易出错,死锁,阻塞,资源浪费等问题需要特别小心处理;二是多线程的调度是由操作管理的,可能不会按照开发者期望的调度方式运行,因此不能精细控制程序的运行.基于事件并发是一种替代方案.它的思路是等待某些事件发生,然后判断事件类型,使用相应的代码处理.基于事件的并发有一个非常重要的架构:eventLoop().典型的基于事件的服务器的伪代码如下:</p>\\n<div class=\\"language-c line-numbers-mode\\" data-highlighter=\\"shiki\\" data-ext=\\"c\\" style=\\"--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34\\"><pre class=\\"shiki shiki-themes one-light one-dark-pro vp-code\\"><code><span class=\\"line\\"><span style=\\"--shiki-light:#A626A4;--shiki-dark:#C678DD\\">while</span><span style=\\"--shiki-light:#383A42;--shiki-dark:#ABB2BF\\">(</span><span style=\\"--shiki-light:#986801;--shiki-dark:#D19A66\\">1</span><span style=\\"--shiki-light:#383A42;--shiki-dark:#ABB2BF\\">) {</span></span>\\n<span class=\\"line\\"><span style=\\"--shiki-light:#383A42;--shiki-dark:#ABB2BF\\">    events </span><span style=\\"--shiki-light:#A626A4;--shiki-dark:#C678DD\\">=</span><span style=\\"--shiki-light:#4078F2;--shiki-dark:#61AFEF\\"> getEvents</span><span style=\\"--shiki-light:#383A42;--shiki-dark:#ABB2BF\\">();</span></span>\\n<span class=\\"line\\"><span style=\\"--shiki-light:#A626A4;--shiki-dark:#C678DD\\">    for</span><span style=\\"--shiki-light:#383A42;--shiki-dark:#ABB2BF\\"> (e in events) </span></span>\\n<span class=\\"line\\"><span style=\\"--shiki-light:#4078F2;--shiki-dark:#61AFEF\\">        processEvent</span><span style=\\"--shiki-light:#383A42;--shiki-dark:#ABB2BF\\">(e);</span></span>\\n<span class=\\"line\\"><span style=\\"--shiki-light:#383A42;--shiki-dark:#ABB2BF\\">}</span></span></code></pre>\\n<div class=\\"line-numbers\\" aria-hidden=\\"true\\" style=\\"counter-reset:line-number 0\\"><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div></div></div>","autoDesc":true}');export{p as comp,d as data};
