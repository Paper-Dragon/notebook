import{a as n,c as o,g as t,o as e}from"./app-Bdxrw26Y.js";const r="/assets/011_%E7%BB%A7%E6%89%BF%E5%AF%B9%E6%AF%94%E5%9B%BE%E7%A4%BA-1H9eT-tk.png",i="/assets/012_%E7%BB%A7%E6%89%BF%E6%96%B9%E6%B3%95%E7%9A%84%E9%87%8D%E5%86%99-AL_Z6aJx.png",a="/assets/013_%E7%88%B6%E7%B1%BB%E7%9A%84%E7%A7%81%E6%9C%89%E5%B1%9E%E6%80%A7%E5%92%8C%E7%A7%81%E6%9C%89%E6%96%B9%E6%B3%95-DQBLTSiN.png",g="/assets/014_%E5%A4%9A%E7%BB%A7%E6%89%BF-B7drAmAG.png",l="/assets/015_%E5%A4%9A%E7%BB%A7%E6%89%BFII-b0Y7ZpZB.png",d={};function h(c,s){return e(),o("div",null,[...s[0]||(s[0]=[t('<h1 id="继承" tabindex="-1"><a class="header-anchor" href="#继承"><span>继承</span></a></h1><h2 id="目标" tabindex="-1"><a class="header-anchor" href="#目标"><span>目标</span></a></h2><ul><li>单继承</li><li>多继承</li></ul><p><strong>面向对象三大特性</strong></p><ol><li><strong>封装</strong> 根据 <strong>职责</strong> 将 <strong>属性</strong> 和 <strong>方法</strong> <strong>封装</strong> 到一个抽象的 <strong>类</strong> 中</li><li><strong>继承</strong> <strong>实现代码的重用</strong>，相同的代码不需要重复的编写</li><li><strong>多态</strong> 不同的对象调用相同的方法，产生不同的执行结果，<strong>增加代码的灵活度</strong></li></ol><h2 id="_01-单继承" tabindex="-1"><a class="header-anchor" href="#_01-单继承"><span>01. 单继承</span></a></h2><h3 id="_1-1-继承的概念、语法和特点" tabindex="-1"><a class="header-anchor" href="#_1-1-继承的概念、语法和特点"><span>1.1 继承的概念、语法和特点</span></a></h3><p><strong>继承的概念</strong>：<strong>子类</strong> 拥有 <strong>父类</strong> 的所有 <strong>方法</strong> 和 <strong>属性</strong></p><p><img src="'+r+`" alt="011_继承对比图示"></p><h4 id="_1-继承的语法" tabindex="-1"><a class="header-anchor" href="#_1-继承的语法"><span>1) 继承的语法</span></a></h4><div class="language-python line-numbers-mode" data-highlighter="shiki" data-ext="python" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code class="language-python"><span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">class</span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;"> 类名</span><span style="--shiki-light:#C18401;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;">父类名</span><span style="--shiki-light:#C18401;--shiki-dark:#ABB2BF;">)</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">:</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">    pass</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ul><li><strong>子类</strong> 继承自 <strong>父类</strong>，可以直接 <strong>享受</strong> 父类中已经封装好的方法，不需要再次开发</li><li><strong>子类</strong> 中应该根据 <strong>职责</strong>，封装 <strong>子类特有的</strong> <strong>属性和方法</strong></li></ul><h4 id="_2-专业术语" tabindex="-1"><a class="header-anchor" href="#_2-专业术语"><span>2) 专业术语</span></a></h4><ul><li><code>Dog</code> 类是 <code>Animal</code> 类的<strong>子类</strong>，<code>Animal</code> 类是 <code>Dog</code> 类的<strong>父类</strong>，<code>Dog</code> 类从 <code>Animal</code> 类<strong>继承</strong></li><li><code>Dog</code> 类是 <code>Animal</code> 类的<strong>派生类</strong>，<code>Animal</code> 类是 <code>Dog</code> 类的<strong>基类</strong>，<code>Dog</code> 类从 <code>Animal</code> 类<strong>派生</strong></li></ul><h4 id="_3-继承的传递性" tabindex="-1"><a class="header-anchor" href="#_3-继承的传递性"><span>3) 继承的传递性</span></a></h4><ul><li><code>C</code> 类从 <code>B</code> 类继承，<code>B</code> 类又从 <code>A</code> 类继承</li><li>那么 <code>C</code> 类就具有 <code>B</code> 类和 <code>A</code> 类的所有属性和方法</li></ul><p><strong>子类</strong> 拥有 <strong>父类</strong> 以及 <strong>父类的父类</strong> 中封装的所有 <strong>属性</strong> 和 <strong>方法</strong></p><p><strong>提问</strong></p><p><strong>哮天犬</strong> 能够调用 <code>Cat</code> 类中定义的 <code>catch</code> 方法吗？</p><p><strong>答案</strong></p><p><strong>不能</strong>，因为 <strong>哮天犬</strong> 和 <code>Cat</code> 之间没有 <strong>继承</strong> 关系</p><h3 id="_1-2-方法的重写" tabindex="-1"><a class="header-anchor" href="#_1-2-方法的重写"><span>1.2 方法的重写</span></a></h3><ul><li><strong>子类</strong> 拥有 <strong>父类</strong> 的所有 <strong>方法</strong> 和 <strong>属性</strong></li><li><strong>子类</strong> 继承自 <strong>父类</strong>，可以直接 <strong>享受</strong> 父类中已经封装好的方法，不需要再次开发</li></ul><p><strong>应用场景</strong></p><ul><li>当 <strong>父类</strong> 的方法实现不能满足子类需求时，可以对方法进行 <strong>重写(override)</strong></li></ul><p><img src="`+i+'" alt="012_继承方法的重写"></p><p><strong>重写</strong> 父类方法有两种情况：</p><ol><li><strong>覆盖</strong> 父类的方法</li><li>对父类方法进行 <strong>扩展</strong></li></ol><h4 id="_1-覆盖父类的方法" tabindex="-1"><a class="header-anchor" href="#_1-覆盖父类的方法"><span>1) 覆盖父类的方法</span></a></h4><ul><li>如果在开发中，<strong>父类的方法实现</strong> 和 <strong>子类的方法实现</strong>，<strong>完全不同</strong></li><li>就可以使用 <strong>覆盖</strong> 的方式，<strong>在子类中</strong> <strong>重新编写</strong> 父类的方法实现</li></ul><blockquote><p>具体的实现方式，就相当于在 <strong>子类中</strong> 定义了一个 <strong>和父类同名的方法并且实现</strong></p></blockquote><p>重写之后，在运行时，<strong>只会调用</strong> 子类中重写的方法，而不再会调用 <strong>父类封装的方法</strong></p><h4 id="_2-对父类方法进行-扩展" tabindex="-1"><a class="header-anchor" href="#_2-对父类方法进行-扩展"><span>2) 对父类方法进行 <strong>扩展</strong></span></a></h4><ul><li>如果在开发中，<strong>子类的方法实现</strong> 中 <strong>包含</strong> <strong>父类的方法实现</strong><ul><li><strong>父类原本封装的方法实现</strong> 是 <strong>子类方法的一部分</strong></li></ul></li><li>就可以使用 <strong>扩展</strong> 的方式 <ol><li><strong>在子类中</strong> <strong>重写</strong> 父类的方法</li><li>在需要的位置使用 <code>super().父类方法</code> 来调用父类方法的执行</li><li>代码其他的位置针对子类的需求，编写 <strong>子类特有的代码实现</strong></li></ol></li></ul><h5 id="关于-super" tabindex="-1"><a class="header-anchor" href="#关于-super"><span>关于 <code>super</code></span></a></h5><ul><li>在 <code>Python</code> 中 <code>super</code> 是一个 <strong>特殊的类</strong></li><li><code>super()</code> 就是使用 <code>super</code> 类创建出来的对象</li><li><strong>最常</strong> 使用的场景就是在 <strong>重写父类方法时</strong>，调用 <strong>在父类中封装的方法实现</strong></li></ul><h5 id="调用父类方法的另外一种方式-知道" tabindex="-1"><a class="header-anchor" href="#调用父类方法的另外一种方式-知道"><span>调用父类方法的另外一种方式（知道）</span></a></h5><blockquote><p>在 <code>Python 2.x</code> 时，如果需要调用父类的方法，还可以使用以下方式：</p></blockquote><div class="language-python line-numbers-mode" data-highlighter="shiki" data-ext="python" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code class="language-python"><span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">父类名.</span><span style="--shiki-light:#383A42;--shiki-dark:#61AFEF;">方法</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;">self</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">)</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><ul><li>这种方式，目前在 <code>Python 3.x</code> 还支持这种方式</li><li>这种方法 <strong>不推荐使用</strong>，因为一旦 <strong>父类发生变化</strong>，方法调用位置的 <strong>类名</strong> 同样需要修改</li></ul><p><strong>提示</strong></p><ul><li>在开发时，<code>父类名</code> 和 <code>super()</code> 两种方式不要混用</li><li>如果使用 <strong>当前子类名</strong> 调用方法，会形成递归调用，<strong>出现死循环</strong></li></ul><h3 id="_1-3-父类的-私有属性-和-私有方法" tabindex="-1"><a class="header-anchor" href="#_1-3-父类的-私有属性-和-私有方法"><span>1.3 父类的 私有属性 和 私有方法</span></a></h3><ol><li><strong>子类对象</strong> <strong>不能</strong> 在自己的方法内部，<strong>直接</strong> 访问 父类的 <strong>私有属性</strong> 或 <strong>私有方法</strong></li><li><strong>子类对象</strong> 可以通过 <strong>父类</strong> 的 <strong>公有方法</strong> <strong>间接</strong> 访问到 <strong>私有属性</strong> 或 <strong>私有方法</strong></li></ol><blockquote><ul><li><strong>私有属性、方法</strong> 是对象的隐私，不对外公开，<strong>外界</strong> 以及 <strong>子类</strong> 都不能直接访问</li><li><strong>私有属性、方法</strong> 通常用于做一些内部的事情</li></ul></blockquote><p><strong>示例</strong></p><p><img src="'+a+'" alt="013_父类的私有属性和私有方法"></p><ul><li><code>B</code> 的对象不能直接访问 <code>__num2</code> 属性</li><li><code>B</code> 的对象不能在 <code>demo</code> 方法内访问 <code>__num2</code> 属性</li><li><code>B</code> 的对象可以在 <code>demo</code> 方法内，调用父类的 <code>test</code> 方法</li><li>父类的 <code>test</code> 方法内部，能够访问 <code>__num2</code> 属性和 <code>__test</code> 方法</li></ul><h2 id="_02-多继承" tabindex="-1"><a class="header-anchor" href="#_02-多继承"><span>02. 多继承</span></a></h2><p><strong>概念</strong></p><ul><li><strong>子类</strong> 可以拥有 <strong>多个父类</strong>，并且具有 <strong>所有父类</strong> 的 <strong>属性</strong> 和 <strong>方法</strong></li><li>例如：<strong>孩子</strong> 会继承自己 <strong>父亲</strong> 和 <strong>母亲</strong> 的 <strong>特性</strong></li></ul><p><img src="'+g+`" alt="014_多继承"></p><p><strong>语法</strong></p><div class="language-python line-numbers-mode" data-highlighter="shiki" data-ext="python" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code class="language-python"><span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">class</span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;"> 子类名</span><span style="--shiki-light:#C18401;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;">父类名1</span><span style="--shiki-light:#C18401;--shiki-dark:#ABB2BF;">, </span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;">父类名2</span><span style="--shiki-light:#383A42;--shiki-dark:#D19A66;">...</span><span style="--shiki-light:#C18401;--shiki-dark:#ABB2BF;">)</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">    pass</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="_2-1-多继承的使用注意事项" tabindex="-1"><a class="header-anchor" href="#_2-1-多继承的使用注意事项"><span>2.1 多继承的使用注意事项</span></a></h3><p><strong>问题的提出</strong></p><ul><li>如果 <strong>不同的父类</strong> 中存在 <strong>同名的方法</strong>，<strong>子类对象</strong> 在调用方法时，会调用 <strong>哪一个父类中</strong>的方法呢？</li></ul><blockquote><p>提示：<strong>开发时，应该尽量避免这种容易产生混淆的情况！</strong> —— 如果 <strong>父类之间</strong> 存在 <strong>同名的属性或者方法</strong>，应该 <strong>尽量避免</strong> 使用多继承</p></blockquote><p><img src="`+l+`" alt="015_多继承II"></p><h4 id="python-中的-mro-——-方法搜索顺序-知道" tabindex="-1"><a class="header-anchor" href="#python-中的-mro-——-方法搜索顺序-知道"><span>Python 中的 MRO —— 方法搜索顺序（知道）</span></a></h4><ul><li><code>Python</code> 中针对 <strong>类</strong> 提供了一个 <strong>内置属性</strong> <code>__mro__</code> 可以查看 <strong>方法</strong> 搜索顺序</li><li>MRO 是 <code>method resolution order</code>，主要用于 <strong>在多继承时判断 方法、属性 的调用 路径</strong></li></ul><div class="language-python line-numbers-mode" data-highlighter="shiki" data-ext="python" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code class="language-python"><span class="line"><span style="--shiki-light:#0184BC;--shiki-dark:#56B6C2;">print</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(C.</span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;">__mro__</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">)</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><p><strong>输出结果</strong></p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code class="language-"><span class="line"><span>(&lt;class &#39;__main__.C&#39;&gt;, &lt;class &#39;__main__.A&#39;&gt;, &lt;class &#39;__main__.B&#39;&gt;, &lt;class &#39;object&#39;&gt;)</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><ul><li>在搜索方法时，是按照 <code>__mro__</code> 的输出结果 <strong>从左至右</strong> 的顺序查找的</li><li>如果在当前类中 <strong>找到方法，就直接执行，不再搜索</strong></li><li>如果 <strong>没有找到，就查找下一个类</strong> 中是否有对应的方法，<strong>如果找到，就直接执行，不再搜索</strong></li><li>如果找到最后一个类，还没有找到方法，程序报错</li></ul><h3 id="_2-2-新式类与旧式-经典-类" tabindex="-1"><a class="header-anchor" href="#_2-2-新式类与旧式-经典-类"><span>2.2 新式类与旧式（经典）类</span></a></h3><blockquote><p><code>object</code> 是 <code>Python</code> 为所有对象提供的 <strong>基类</strong>，提供有一些内置的属性和方法，可以使用 <code>dir</code> 函数查看</p></blockquote><ul><li><p><strong>新式类</strong>：以 <code>object</code> 为基类的类，<strong>推荐使用</strong></p></li><li><p><strong>经典类</strong>：不以 <code>object</code> 为基类的类，<strong>不推荐使用</strong></p></li><li><p>在 <code>Python 3.x</code> 中定义类时，如果没有指定父类，会 <strong>默认使用</strong> <code>object</code> 作为该类的 <strong>基类</strong> —— <code>Python 3.x</code> 中定义的类都是 <strong>新式类</strong></p></li><li><p>在 <code>Python 2.x</code> 中定义类时，如果没有指定父类，则不会以 <code>object</code> 作为 <strong>基类</strong></p></li></ul><blockquote><p><strong>新式类</strong> 和 <strong>经典类</strong> 在多继承时 —— <strong>会影响到方法的搜索顺序</strong></p></blockquote><p>为了保证编写的代码能够同时在 <code>Python 2.x</code> 和 <code>Python 3.x</code> 运行！ 今后在定义类时，<strong>如果没有父类，建议统一继承自 <code>object</code></strong></p><div class="language-python line-numbers-mode" data-highlighter="shiki" data-ext="python" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code class="language-python"><span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">class</span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;"> 类名</span><span style="--shiki-light:#C18401;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#0184BC;--shiki-dark:#56B6C2;">object</span><span style="--shiki-light:#C18401;--shiki-dark:#ABB2BF;">)</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">:</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">    pass</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div></div></div>`,71)])])}const k=n(d,[["render",h]]),u=JSON.parse('{"path":"/note-book/Research_Develop/Python/python%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/09_%E7%BB%A7%E6%89%BF.html","title":"继承","lang":"zh-CN","frontmatter":{"description":"继承 目标 单继承 多继承 面向对象三大特性 封装 根据 职责 将 属性 和 方法 封装 到一个抽象的 类 中 继承 实现代码的重用，相同的代码不需要重复的编写 多态 不同的对象调用相同的方法，产生不同的执行结果，增加代码的灵活度 01. 单继承 1.1 继承的概念、语法和特点 继承的概念：子类 拥有 父类 的所有 方法 和 属性 011_继承对比图示...","head":[["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"继承\\",\\"image\\":[\\"\\"],\\"dateModified\\":\\"2024-03-19T07:56:45.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"Paper-Dragon\\",\\"url\\":\\"https://github.com/Paper-Dragon\\",\\"email\\":\\"2678885646@qq.com\\"}]}"],["meta",{"property":"og:url","content":"https://www.geekery.cn/note-book/Research_Develop/Python/python%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/09_%E7%BB%A7%E6%89%BF.html"}],["meta",{"property":"og:site_name","content":"运维开发绿皮书"}],["meta",{"property":"og:title","content":"继承"}],["meta",{"property":"og:description","content":"继承 目标 单继承 多继承 面向对象三大特性 封装 根据 职责 将 属性 和 方法 封装 到一个抽象的 类 中 继承 实现代码的重用，相同的代码不需要重复的编写 多态 不同的对象调用相同的方法，产生不同的执行结果，增加代码的灵活度 01. 单继承 1.1 继承的概念、语法和特点 继承的概念：子类 拥有 父类 的所有 方法 和 属性 011_继承对比图示..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2024-03-19T07:56:45.000Z"}],["meta",{"property":"article:modified_time","content":"2024-03-19T07:56:45.000Z"}]]},"git":{"createdTime":1691939318000,"updatedTime":1710835005000,"contributors":[{"name":"Paper-Dragon","username":"Paper-Dragon","email":"2678885646@qq.com","commits":1,"url":"https://github.com/Paper-Dragon"},{"name":"PaperDragon-SH","username":"PaperDragon-SH","email":"2678885646@qq.com","commits":1,"url":"https://github.com/PaperDragon-SH"}],"changelog":[{"hash":"cb0daa33b6329eb21784aa12ccdc214113fb2885","time":1710835005000,"email":"2678885646@qq.com","author":"PaperDragon-SH","message":"c"},{"hash":"392a519398b2e846f316619fbe831e100164de7c","time":1691939318000,"email":"2678885646@qq.com","author":"Paper-Dragon","message":"Create The Worid!"}]},"readingTime":{"minutes":5.79,"words":1736},"filePathRelative":"note-book/Research_Develop/Python/python面向对象/09_继承.md","excerpt":"\\n<h2>目标</h2>\\n<ul>\\n<li>单继承</li>\\n<li>多继承</li>\\n</ul>\\n<p><strong>面向对象三大特性</strong></p>\\n<ol>\\n<li><strong>封装</strong> 根据 <strong>职责</strong> 将 <strong>属性</strong> 和 <strong>方法</strong> <strong>封装</strong> 到一个抽象的 <strong>类</strong> 中</li>\\n<li><strong>继承</strong> <strong>实现代码的重用</strong>，相同的代码不需要重复的编写</li>\\n<li><strong>多态</strong> 不同的对象调用相同的方法，产生不同的执行结果，<strong>增加代码的灵活度</strong></li>\\n</ol>","autoDesc":true}');export{k as comp,u as data};
