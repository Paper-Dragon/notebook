import{aq as a,ar as i,aw as e,av as n}from"./app-CAvr0TXp.js";const t="/assets/20180814091117710-CSzf8Oup.png",r="/assets/20180814090822600-BsFjl4fm.png",p={};function h(l,s){return n(),i("div",null,s[0]||(s[0]=[e(`<h1 id="linux关闭地址空间随机化-aslr" tabindex="-1"><a class="header-anchor" href="#linux关闭地址空间随机化-aslr"><span>Linux关闭地址空间随机化（ASLR）</span></a></h1><h2 id="_0x00-背景知识" tabindex="-1"><a class="header-anchor" href="#_0x00-背景知识"><span>0x00 背景知识</span></a></h2><p>ASLR(Address Space Layout Randomization)在2005年被引入到Linux的内核 kernel 2.6.12 中，当然早在2004年就以patch的形式被引入。随着内存地址的随机化，使得响应的应用变得随机。这意味着同一应用多次执行所使用内存空间完全不同，也意味着简单的缓冲区溢出攻击无法达到目的。</p><p>GDB从版本7开始，第一次在Ubuntu 9.10（Karmic）上，被调试的程序可以被关闭ASLR（通过标记位ADDR_NO_RANDOMIZE ）。</p><p>此处有坑，笔者有一个Ubuntu 9.10的虚拟机，用了下面将要介绍的全部姿势，死活关闭不了ASLR，后来换成Ubuntu 10.04就没问题了，说明Ubuntu 9.10的版本控制ASLR的方法还不成熟，需要重源码层面确认是否可以关闭开启，真是坑到家了。</p><h2 id="_0x01-查看aslr设置" tabindex="-1"><a class="header-anchor" href="#_0x01-查看aslr设置"><span>0x01 查看ASLR设置</span></a></h2><p>查看当前操作系统的ASLR配置情况，两种命令任你选择</p><pre><code>$ cat /proc/sys/kernel/randomize_va_space
2
$ sysctl -a --pattern randomize
kernel.randomize_va_space = 2
</code></pre><h2 id="_0x02-配置选项" tabindex="-1"><a class="header-anchor" href="#_0x02-配置选项"><span>0x02 配置选项</span></a></h2><pre><code>0 = 关闭
1 = 半随机。共享库、栈、mmap() 以及 VDSO 将被随机化。（留坑，PIE会影响heap的随机化。。）
2 = 全随机。除了1中所述，还有heap。
</code></pre><p>后面会详细介绍ASLR的组成，不关心的同学可以简单理解为ASLR不是一个笼统的概念，而是要按模块单独实现的。当然，在攻防对抗的角度上，应为不是所有组件都会随机，所以我们就可以按图索骥，写出通用的shellcode调用系统库。</p><h2 id="_0x03-查看地址空间随机效果" tabindex="-1"><a class="header-anchor" href="#_0x03-查看地址空间随机效果"><span>0x03 查看地址空间随机效果</span></a></h2><p>使用ldd命令就可以观察到程序所依赖动态加载模块的地址空间，如下下图所示，被括号包裹。在shell中，运行两次相同的ldd命令，即可对比出前后地址的不同之处，当然，ASLR开启时才会变化：</p><p>ASLR开启时，动态库的加载地址不同</p><p><img src="`+t+'" alt="这里写图片描述"></p><p>ASLR关闭时，动态库的加载地址相同</p><p><img src="'+r+`" alt="这里写图片描述"></p><h2 id="_0x04-关闭aslr" tabindex="-1"><a class="header-anchor" href="#_0x04-关闭aslr"><span>0x04 关闭ASLR</span></a></h2><p>方法一： 手动修改randomize_va_space文件</p><p>诚如上面介绍的randomize_va_space文件的枚举值含义，设置的值不同，linux内核加载程序的地址空间的策略就会不同。比较简单明了。这里0代表关闭ASLR。</p><div class="language-bash line-numbers-mode" data-highlighter="shiki" data-ext="bash" data-title="bash" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#0184BC;--shiki-dark:#56B6C2;">echo</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;"> 0</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> &gt; </span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;">/proc/sys/kernel/randomize_va_space</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><p>注意，这里是先进root权限，后执行。不要问为什么sudo echo 0 &gt; /proc/sys/kernel/randomize_va_space为什么会报错 方法二： 使用sysctl控制ASLR</p><div class="language-bash line-numbers-mode" data-highlighter="shiki" data-ext="bash" data-title="bash" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">$</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> sysctl</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;"> -w</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> kernel.randomize_va_space=0xxxxxxxxxx1 1</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">$ </span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;">sysctl</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;"> -w</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> kernel.randomize_va_space=</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;">01</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><p>这是一种临时改变随机策略的方法，重启之后将恢复默认。如果需要永久保存配置，需要在配置文件 /etc/sysctl.conf 中增加这个选项。 方法三： 使用setarch控制单个程序的随机化</p><p>如果你想历史关闭单个程序的ASLR，使用setarch是很好的选择。setarch命令如其名，改变程序的运行架构环境，并可以自定义环境flag。</p><div class="language-bash line-numbers-mode" data-highlighter="shiki" data-ext="bash" data-title="bash" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">setarch</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> \`</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">uname</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;"> -m</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;">\`</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;"> -R</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> ./your_program</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><p>-R参数代表关闭地址空间随机化（开启ADDR_NO_RANDOMIZE) 方法四： 在GDB场景下，使用set disable-randomization off</p><p>在调试特定程序时，可以通过set disable-randomization命令开启或者关闭地址空间随机化。默认是关闭随机化的，也就是on状态。</p><p>当然，这里开启，关闭和查看的方法看起来就比较正规了。</p><div class="language-bash line-numbers-mode" data-highlighter="shiki" data-ext="bash" data-title="bash" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">关闭ASLR：</span></span>
<span class="line"><span style="--shiki-light:#0184BC;--shiki-dark:#56B6C2;">set</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> disable-randomization</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> on</span></span>
<span class="line"><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">开启ASLR：</span></span>
<span class="line"><span style="--shiki-light:#0184BC;--shiki-dark:#56B6C2;">set</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> disable-randomization</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> off</span></span>
<span class="line"><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">查看ASLR状态：</span></span>
<span class="line"><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">show</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> disable-randomization</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2 id="_0x05-aslr与pie的区别" tabindex="-1"><a class="header-anchor" href="#_0x05-aslr与pie的区别"><span>0x05 ASLR与PIE的区别</span></a></h2><p>ASLR有一个模糊的值（1），既不是全开启也不是全关闭，而是部分关闭，那这部分到底是什么，很容易产生歧义。</p><p>ASLR 不负责代码段以及数据段的随机化工作，这项工作由 PIE 负责。但是只有在开启 ASLR 之后，PIE 才会生效。</p><h2 id="_0x06-一些没有用的感想" tabindex="-1"><a class="header-anchor" href="#_0x06-一些没有用的感想"><span>0x06 一些没有用的感想</span></a></h2><p>写这篇文章的原点是在调试一个简单的ROP利用没有成功弹shell，但是出了一些莫名其妙的sh报错。冥冥中感觉里成功不远了。随着翻阅资料的积累，和相关writeup的release date接近2018年，越来越坚定了这份信心。终于找到了ASLR的影响导致ROP不成功的原因。</p><p>最近工作也很累，不是量大，而是心累。希望LP越来越漂亮，越来越美丽～</p>`,36)]))}const o=a(p,[["render",h],["__file","Linux关闭地址空间随机化（ASLR）.html.vue"]]),c=JSON.parse('{"path":"/note-book/OperaSystems/Ubuntu/Linux%E5%85%B3%E9%97%AD%E5%9C%B0%E5%9D%80%E7%A9%BA%E9%97%B4%E9%9A%8F%E6%9C%BA%E5%8C%96%EF%BC%88ASLR%EF%BC%89.html","title":"Linux关闭地址空间随机化（ASLR）","lang":"zh-CN","frontmatter":{"description":"Linux关闭地址空间随机化（ASLR） 0x00 背景知识 ASLR(Address Space Layout Randomization)在2005年被引入到Linux的内核 kernel 2.6.12 中，当然早在2004年就以patch的形式被引入。随着内存地址的随机化，使得响应的应用变得随机。这意味着同一应用多次执行所使用内存空间完全不同，也...","head":[["meta",{"property":"og:url","content":"https://www.geekery.cn/note-book/OperaSystems/Ubuntu/Linux%E5%85%B3%E9%97%AD%E5%9C%B0%E5%9D%80%E7%A9%BA%E9%97%B4%E9%9A%8F%E6%9C%BA%E5%8C%96%EF%BC%88ASLR%EF%BC%89.html"}],["meta",{"property":"og:site_name","content":"运维开发绿皮书"}],["meta",{"property":"og:title","content":"Linux关闭地址空间随机化（ASLR）"}],["meta",{"property":"og:description","content":"Linux关闭地址空间随机化（ASLR） 0x00 背景知识 ASLR(Address Space Layout Randomization)在2005年被引入到Linux的内核 kernel 2.6.12 中，当然早在2004年就以patch的形式被引入。随着内存地址的随机化，使得响应的应用变得随机。这意味着同一应用多次执行所使用内存空间完全不同，也..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2024-03-25T08:45:20.000Z"}],["meta",{"property":"article:modified_time","content":"2024-03-25T08:45:20.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"Linux关闭地址空间随机化（ASLR）\\",\\"image\\":[\\"\\"],\\"dateModified\\":\\"2024-03-25T08:45:20.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"PaperDragon\\",\\"url\\":\\"https://github.com/Paper-Dragon\\",\\"email\\":\\"2678885646@qq.com\\"}]}"]]},"git":{"createdTime":1691939318000,"updatedTime":1711356320000,"contributors":[{"name":"PaperDragon","username":"PaperDragon","email":"2678885646@qq.com","commits":1,"url":"https://github.com/PaperDragon"},{"name":"PaperDragon-SH","username":"PaperDragon-SH","email":"2678885646@qq.com","commits":3,"url":"https://github.com/PaperDragon-SH"}]},"readingTime":{"minutes":3.84,"words":1151},"filePathRelative":"note-book/OperaSystems/Ubuntu/Linux关闭地址空间随机化（ASLR）.md","localizedDate":"2023年8月13日","excerpt":"\\n<h2>0x00 背景知识</h2>\\n<p>ASLR(Address Space Layout Randomization)在2005年被引入到Linux的内核 kernel 2.6.12 中，当然早在2004年就以patch的形式被引入。随着内存地址的随机化，使得响应的应用变得随机。这意味着同一应用多次执行所使用内存空间完全不同，也意味着简单的缓冲区溢出攻击无法达到目的。</p>\\n<p>GDB从版本7开始，第一次在Ubuntu 9.10（Karmic）上，被调试的程序可以被关闭ASLR（通过标记位ADDR_NO_RANDOMIZE ）。</p>\\n<p>此处有坑，笔者有一个Ubuntu 9.10的虚拟机，用了下面将要介绍的全部姿势，死活关闭不了ASLR，后来换成Ubuntu 10.04就没问题了，说明Ubuntu 9.10的版本控制ASLR的方法还不成熟，需要重源码层面确认是否可以关闭开启，真是坑到家了。</p>","autoDesc":true}');export{o as comp,c as data};
