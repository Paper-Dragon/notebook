import{_ as n}from"./plugin-vue_export-helper-DlAUqK2U.js";import{aj as t,ao as o,am as e}from"./app-DCr7N1U1.js";const i="/assets/011_%E7%BB%A7%E6%89%BF%E5%AF%B9%E6%AF%94%E5%9B%BE%E7%A4%BA-1H9eT-tk.png",r="/assets/012_%E7%BB%A7%E6%89%BF%E6%96%B9%E6%B3%95%E7%9A%84%E9%87%8D%E5%86%99-AL_Z6aJx.png",l="/assets/013_%E7%88%B6%E7%B1%BB%E7%9A%84%E7%A7%81%E6%9C%89%E5%B1%9E%E6%80%A7%E5%92%8C%E7%A7%81%E6%9C%89%E6%96%B9%E6%B3%95-DQBLTSiN.png",a="/assets/014_%E5%A4%9A%E7%BB%A7%E6%89%BF-B7drAmAG.png",g="/assets/015_%E5%A4%9A%E7%BB%A7%E6%89%BFII-b0Y7ZpZB.png",d={};function c(h,s){return e(),t("div",null,s[0]||(s[0]=[o('<h1 id="继承" tabindex="-1"><a class="header-anchor" href="#继承"><span>继承</span></a></h1><h2 id="目标" tabindex="-1"><a class="header-anchor" href="#目标"><span>目标</span></a></h2><ul><li>单继承</li><li>多继承</li></ul><p><strong>面向对象三大特性</strong></p><ol><li><strong>封装</strong> 根据 <strong>职责</strong> 将 <strong>属性</strong> 和 <strong>方法</strong> <strong>封装</strong> 到一个抽象的 <strong>类</strong> 中</li><li><strong>继承</strong> <strong>实现代码的重用</strong>，相同的代码不需要重复的编写</li><li><strong>多态</strong> 不同的对象调用相同的方法，产生不同的执行结果，<strong>增加代码的灵活度</strong></li></ol><h2 id="_01-单继承" tabindex="-1"><a class="header-anchor" href="#_01-单继承"><span>01. 单继承</span></a></h2><h3 id="_1-1-继承的概念、语法和特点" tabindex="-1"><a class="header-anchor" href="#_1-1-继承的概念、语法和特点"><span>1.1 继承的概念、语法和特点</span></a></h3><p><strong>继承的概念</strong>：<strong>子类</strong> 拥有 <strong>父类</strong> 的所有 <strong>方法</strong> 和 <strong>属性</strong></p><figure><img src="'+i+`" alt="011_继承对比图示" tabindex="0" loading="lazy"><figcaption>011_继承对比图示</figcaption></figure><h4 id="_1-继承的语法" tabindex="-1"><a class="header-anchor" href="#_1-继承的语法"><span>1) 继承的语法</span></a></h4><div class="language-python line-numbers-mode" data-highlighter="shiki" data-ext="python" data-title="python" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">class</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> 类名(父类名):</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">    pass</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ul><li><strong>子类</strong> 继承自 <strong>父类</strong>，可以直接 <strong>享受</strong> 父类中已经封装好的方法，不需要再次开发</li><li><strong>子类</strong> 中应该根据 <strong>职责</strong>，封装 <strong>子类特有的</strong> <strong>属性和方法</strong></li></ul><h4 id="_2-专业术语" tabindex="-1"><a class="header-anchor" href="#_2-专业术语"><span>2) 专业术语</span></a></h4><ul><li><code>Dog</code> 类是 <code>Animal</code> 类的<strong>子类</strong>，<code>Animal</code> 类是 <code>Dog</code> 类的<strong>父类</strong>，<code>Dog</code> 类从 <code>Animal</code> 类<strong>继承</strong></li><li><code>Dog</code> 类是 <code>Animal</code> 类的<strong>派生类</strong>，<code>Animal</code> 类是 <code>Dog</code> 类的<strong>基类</strong>，<code>Dog</code> 类从 <code>Animal</code> 类<strong>派生</strong></li></ul><h4 id="_3-继承的传递性" tabindex="-1"><a class="header-anchor" href="#_3-继承的传递性"><span>3) 继承的传递性</span></a></h4><ul><li><code>C</code> 类从 <code>B</code> 类继承，<code>B</code> 类又从 <code>A</code> 类继承</li><li>那么 <code>C</code> 类就具有 <code>B</code> 类和 <code>A</code> 类的所有属性和方法</li></ul><p><strong>子类</strong> 拥有 <strong>父类</strong> 以及 <strong>父类的父类</strong> 中封装的所有 <strong>属性</strong> 和 <strong>方法</strong></p><p><strong>提问</strong></p><p><strong>哮天犬</strong> 能够调用 <code>Cat</code> 类中定义的 <code>catch</code> 方法吗？</p><p><strong>答案</strong></p><p><strong>不能</strong>，因为 <strong>哮天犬</strong> 和 <code>Cat</code> 之间没有 <strong>继承</strong> 关系</p><h3 id="_1-2-方法的重写" tabindex="-1"><a class="header-anchor" href="#_1-2-方法的重写"><span>1.2 方法的重写</span></a></h3><ul><li><strong>子类</strong> 拥有 <strong>父类</strong> 的所有 <strong>方法</strong> 和 <strong>属性</strong></li><li><strong>子类</strong> 继承自 <strong>父类</strong>，可以直接 <strong>享受</strong> 父类中已经封装好的方法，不需要再次开发</li></ul><p><strong>应用场景</strong></p><ul><li>当 <strong>父类</strong> 的方法实现不能满足子类需求时，可以对方法进行 <strong>重写(override)</strong></li></ul><figure><img src="`+r+'" alt="012_继承方法的重写" tabindex="0" loading="lazy"><figcaption>012_继承方法的重写</figcaption></figure><p><strong>重写</strong> 父类方法有两种情况：</p><ol><li><strong>覆盖</strong> 父类的方法</li><li>对父类方法进行 <strong>扩展</strong></li></ol><h4 id="_1-覆盖父类的方法" tabindex="-1"><a class="header-anchor" href="#_1-覆盖父类的方法"><span>1) 覆盖父类的方法</span></a></h4><ul><li>如果在开发中，<strong>父类的方法实现</strong> 和 <strong>子类的方法实现</strong>，<strong>完全不同</strong></li><li>就可以使用 <strong>覆盖</strong> 的方式，<strong>在子类中</strong> <strong>重新编写</strong> 父类的方法实现</li></ul><blockquote><p>具体的实现方式，就相当于在 <strong>子类中</strong> 定义了一个 <strong>和父类同名的方法并且实现</strong></p></blockquote><p>重写之后，在运行时，<strong>只会调用</strong> 子类中重写的方法，而不再会调用 <strong>父类封装的方法</strong></p><h4 id="_2-对父类方法进行-扩展" tabindex="-1"><a class="header-anchor" href="#_2-对父类方法进行-扩展"><span>2) 对父类方法进行 <strong>扩展</strong></span></a></h4><ul><li>如果在开发中，<strong>子类的方法实现</strong> 中 <strong>包含</strong> <strong>父类的方法实现</strong><ul><li><strong>父类原本封装的方法实现</strong> 是 <strong>子类方法的一部分</strong></li></ul></li><li>就可以使用 <strong>扩展</strong> 的方式 <ol><li><strong>在子类中</strong> <strong>重写</strong> 父类的方法</li><li>在需要的位置使用 <code>super().父类方法</code> 来调用父类方法的执行</li><li>代码其他的位置针对子类的需求，编写 <strong>子类特有的代码实现</strong></li></ol></li></ul><h5 id="关于-super" tabindex="-1"><a class="header-anchor" href="#关于-super"><span>关于 <code>super</code></span></a></h5><ul><li>在 <code>Python</code> 中 <code>super</code> 是一个 <strong>特殊的类</strong></li><li><code>super()</code> 就是使用 <code>super</code> 类创建出来的对象</li><li><strong>最常</strong> 使用的场景就是在 <strong>重写父类方法时</strong>，调用 <strong>在父类中封装的方法实现</strong></li></ul><h5 id="调用父类方法的另外一种方式-知道" tabindex="-1"><a class="header-anchor" href="#调用父类方法的另外一种方式-知道"><span>调用父类方法的另外一种方式（知道）</span></a></h5><blockquote><p>在 <code>Python 2.x</code> 时，如果需要调用父类的方法，还可以使用以下方式：</p></blockquote><div class="language-python line-numbers-mode" data-highlighter="shiki" data-ext="python" data-title="python" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">父类名.方法(</span><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;">self</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">)</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><ul><li>这种方式，目前在 <code>Python 3.x</code> 还支持这种方式</li><li>这种方法 <strong>不推荐使用</strong>，因为一旦 <strong>父类发生变化</strong>，方法调用位置的 <strong>类名</strong> 同样需要修改</li></ul><p><strong>提示</strong></p><ul><li>在开发时，<code>父类名</code> 和 <code>super()</code> 两种方式不要混用</li><li>如果使用 <strong>当前子类名</strong> 调用方法，会形成递归调用，<strong>出现死循环</strong></li></ul><h3 id="_1-3-父类的-私有属性-和-私有方法" tabindex="-1"><a class="header-anchor" href="#_1-3-父类的-私有属性-和-私有方法"><span>1.3 父类的 私有属性 和 私有方法</span></a></h3><ol><li><strong>子类对象</strong> <strong>不能</strong> 在自己的方法内部，<strong>直接</strong> 访问 父类的 <strong>私有属性</strong> 或 <strong>私有方法</strong></li><li><strong>子类对象</strong> 可以通过 <strong>父类</strong> 的 <strong>公有方法</strong> <strong>间接</strong> 访问到 <strong>私有属性</strong> 或 <strong>私有方法</strong></li></ol><blockquote><ul><li><strong>私有属性、方法</strong> 是对象的隐私，不对外公开，<strong>外界</strong> 以及 <strong>子类</strong> 都不能直接访问</li><li><strong>私有属性、方法</strong> 通常用于做一些内部的事情</li></ul></blockquote><p><strong>示例</strong></p><figure><img src="'+l+'" alt="013_父类的私有属性和私有方法" tabindex="0" loading="lazy"><figcaption>013_父类的私有属性和私有方法</figcaption></figure><ul><li><code>B</code> 的对象不能直接访问 <code>__num2</code> 属性</li><li><code>B</code> 的对象不能在 <code>demo</code> 方法内访问 <code>__num2</code> 属性</li><li><code>B</code> 的对象可以在 <code>demo</code> 方法内，调用父类的 <code>test</code> 方法</li><li>父类的 <code>test</code> 方法内部，能够访问 <code>__num2</code> 属性和 <code>__test</code> 方法</li></ul><h2 id="_02-多继承" tabindex="-1"><a class="header-anchor" href="#_02-多继承"><span>02. 多继承</span></a></h2><p><strong>概念</strong></p><ul><li><strong>子类</strong> 可以拥有 <strong>多个父类</strong>，并且具有 <strong>所有父类</strong> 的 <strong>属性</strong> 和 <strong>方法</strong></li><li>例如：<strong>孩子</strong> 会继承自己 <strong>父亲</strong> 和 <strong>母亲</strong> 的 <strong>特性</strong></li></ul><figure><img src="'+a+`" alt="014_多继承" tabindex="0" loading="lazy"><figcaption>014_多继承</figcaption></figure><p><strong>语法</strong></p><div class="language-python line-numbers-mode" data-highlighter="shiki" data-ext="python" data-title="python" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">class</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> 子类名(父类名1, 父类名2</span><span style="--shiki-light:#383A42;--shiki-dark:#D19A66;">...</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">)</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">    pass</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="_2-1-多继承的使用注意事项" tabindex="-1"><a class="header-anchor" href="#_2-1-多继承的使用注意事项"><span>2.1 多继承的使用注意事项</span></a></h3><p><strong>问题的提出</strong></p><ul><li>如果 <strong>不同的父类</strong> 中存在 <strong>同名的方法</strong>，<strong>子类对象</strong> 在调用方法时，会调用 <strong>哪一个父类中</strong>的方法呢？</li></ul><blockquote><p>提示：<strong>开发时，应该尽量避免这种容易产生混淆的情况！</strong> —— 如果 <strong>父类之间</strong> 存在 <strong>同名的属性或者方法</strong>，应该 <strong>尽量避免</strong> 使用多继承</p></blockquote><figure><img src="`+g+`" alt="015_多继承II" tabindex="0" loading="lazy"><figcaption>015_多继承II</figcaption></figure><h4 id="python-中的-mro-——-方法搜索顺序-知道" tabindex="-1"><a class="header-anchor" href="#python-中的-mro-——-方法搜索顺序-知道"><span>Python 中的 MRO —— 方法搜索顺序（知道）</span></a></h4><ul><li><code>Python</code> 中针对 <strong>类</strong> 提供了一个 <strong>内置属性</strong> <code>__mro__</code> 可以查看 <strong>方法</strong> 搜索顺序</li><li>MRO 是 <code>method resolution order</code>，主要用于 <strong>在多继承时判断 方法、属性 的调用 路径</strong></li></ul><div class="language-python line-numbers-mode" data-highlighter="shiki" data-ext="python" data-title="python" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#0184BC;--shiki-dark:#56B6C2;">print</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(C.</span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;">__mro__</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">)</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><p><strong>输出结果</strong></p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" data-title="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>(&lt;class &#39;__main__.C&#39;&gt;, &lt;class &#39;__main__.A&#39;&gt;, &lt;class &#39;__main__.B&#39;&gt;, &lt;class &#39;object&#39;&gt;)</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><ul><li>在搜索方法时，是按照 <code>__mro__</code> 的输出结果 <strong>从左至右</strong> 的顺序查找的</li><li>如果在当前类中 <strong>找到方法，就直接执行，不再搜索</strong></li><li>如果 <strong>没有找到，就查找下一个类</strong> 中是否有对应的方法，<strong>如果找到，就直接执行，不再搜索</strong></li><li>如果找到最后一个类，还没有找到方法，程序报错</li></ul><h3 id="_2-2-新式类与旧式-经典-类" tabindex="-1"><a class="header-anchor" href="#_2-2-新式类与旧式-经典-类"><span>2.2 新式类与旧式（经典）类</span></a></h3><blockquote><p><code>object</code> 是 <code>Python</code> 为所有对象提供的 <strong>基类</strong>，提供有一些内置的属性和方法，可以使用 <code>dir</code> 函数查看</p></blockquote><ul><li><p><strong>新式类</strong>：以 <code>object</code> 为基类的类，<strong>推荐使用</strong></p></li><li><p><strong>经典类</strong>：不以 <code>object</code> 为基类的类，<strong>不推荐使用</strong></p></li><li><p>在 <code>Python 3.x</code> 中定义类时，如果没有指定父类，会 <strong>默认使用</strong> <code>object</code> 作为该类的 <strong>基类</strong> —— <code>Python 3.x</code> 中定义的类都是 <strong>新式类</strong></p></li><li><p>在 <code>Python 2.x</code> 中定义类时，如果没有指定父类，则不会以 <code>object</code> 作为 <strong>基类</strong></p></li></ul><blockquote><p><strong>新式类</strong> 和 <strong>经典类</strong> 在多继承时 —— <strong>会影响到方法的搜索顺序</strong></p></blockquote><p>为了保证编写的代码能够同时在 <code>Python 2.x</code> 和 <code>Python 3.x</code> 运行！ 今后在定义类时，<strong>如果没有父类，建议统一继承自 <code>object</code></strong></p><div class="language-python line-numbers-mode" data-highlighter="shiki" data-ext="python" data-title="python" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">class</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> 类名(</span><span style="--shiki-light:#0184BC;--shiki-dark:#56B6C2;">object</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">):</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">    pass</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div></div></div>`,71)]))}const u=n(d,[["render",c],["__file","09_继承.html.vue"]]),_=JSON.parse('{"path":"/note-book/Research_Develop/Python/python%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/09_%E7%BB%A7%E6%89%BF.html","title":"继承","lang":"zh-CN","frontmatter":{"description":"继承 目标 单继承 多继承 面向对象三大特性 封装 根据 职责 将 属性 和 方法 封装 到一个抽象的 类 中 继承 实现代码的重用，相同的代码不需要重复的编写 多态 不同的对象调用相同的方法，产生不同的执行结果，增加代码的灵活度 01. 单继承 1.1 继承的概念、语法和特点 继承的概念：子类 拥有 父类 的所有 方法 和 属性 011_继承对比图示...","head":[["meta",{"property":"og:url","content":"https://www.geekery.cn/note-book/Research_Develop/Python/python%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/09_%E7%BB%A7%E6%89%BF.html"}],["meta",{"property":"og:site_name","content":"运维开发绿皮书"}],["meta",{"property":"og:title","content":"继承"}],["meta",{"property":"og:description","content":"继承 目标 单继承 多继承 面向对象三大特性 封装 根据 职责 将 属性 和 方法 封装 到一个抽象的 类 中 继承 实现代码的重用，相同的代码不需要重复的编写 多态 不同的对象调用相同的方法，产生不同的执行结果，增加代码的灵活度 01. 单继承 1.1 继承的概念、语法和特点 继承的概念：子类 拥有 父类 的所有 方法 和 属性 011_继承对比图示..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2024-03-19T07:56:45.000Z"}],["meta",{"property":"article:modified_time","content":"2024-03-19T07:56:45.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"继承\\",\\"image\\":[\\"\\"],\\"dateModified\\":\\"2024-03-19T07:56:45.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"PaperDragon\\",\\"url\\":\\"https://github.com/Paper-Dragon\\",\\"email\\":\\"2678885646@qq.com\\"}]}"]]},"headers":[{"level":2,"title":"目标","slug":"目标","link":"#目标","children":[]},{"level":2,"title":"01. 单继承","slug":"_01-单继承","link":"#_01-单继承","children":[{"level":3,"title":"1.1 继承的概念、语法和特点","slug":"_1-1-继承的概念、语法和特点","link":"#_1-1-继承的概念、语法和特点","children":[]},{"level":3,"title":"1.2 方法的重写","slug":"_1-2-方法的重写","link":"#_1-2-方法的重写","children":[]},{"level":3,"title":"1.3 父类的 私有属性 和 私有方法","slug":"_1-3-父类的-私有属性-和-私有方法","link":"#_1-3-父类的-私有属性-和-私有方法","children":[]}]},{"level":2,"title":"02. 多继承","slug":"_02-多继承","link":"#_02-多继承","children":[{"level":3,"title":"2.1 多继承的使用注意事项","slug":"_2-1-多继承的使用注意事项","link":"#_2-1-多继承的使用注意事项","children":[]},{"level":3,"title":"2.2 新式类与旧式（经典）类","slug":"_2-2-新式类与旧式-经典-类","link":"#_2-2-新式类与旧式-经典-类","children":[]}]}],"git":{"createdTime":1691939318000,"updatedTime":1710835005000,"contributors":[{"name":"PaperDragon-SH","email":"2678885646@qq.com","commits":1}]},"readingTime":{"minutes":5.79,"words":1736},"filePathRelative":"note-book/Research_Develop/Python/python面向对象/09_继承.md","localizedDate":"2023年8月13日","excerpt":"\\n<h2>目标</h2>\\n<ul>\\n<li>单继承</li>\\n<li>多继承</li>\\n</ul>\\n<p><strong>面向对象三大特性</strong></p>\\n<ol>\\n<li><strong>封装</strong> 根据 <strong>职责</strong> 将 <strong>属性</strong> 和 <strong>方法</strong> <strong>封装</strong> 到一个抽象的 <strong>类</strong> 中</li>\\n<li><strong>继承</strong> <strong>实现代码的重用</strong>，相同的代码不需要重复的编写</li>\\n<li><strong>多态</strong> 不同的对象调用相同的方法，产生不同的执行结果，<strong>增加代码的灵活度</strong></li>\\n</ol>","autoDesc":true}');export{u as comp,_ as data};
