import{ah as n,ai as t,ar as e,am as o}from"./app-BMcHTqkZ.js";const g="/assets/atomicity_violation_bug-x-lSQPpB.png",u="/assets/atomicity_violation_bug_fix-560YSslW.png",s="/assets/orderring_violation_bug-i1D1KzRF.png",a="/assets/orderring_violation_bug_fix-C-OKqdzt.png",c="/assets/deadLock_example-B4jFyhta.png",i="/assets/deadlock_gragh-CwfUTQ44.png",b={};function l(p,r){return o(),t("div",null,r[0]||(r[0]=[e('<h1 id="_32-concurrency-bugs-并发bug" tabindex="-1"><a class="header-anchor" href="#_32-concurrency-bugs-并发bug"><span>32 Concurrency Bugs 并发bug</span></a></h1><p><strong>概述:</strong><br> 由于并发的复杂性和不可控性,很容易产生并发bug.并发bug主要分为死锁bug和非死锁bug.非死锁bug又主要有两类,一类是违背原子性bug,一类是违背顺序性bug.</p><ol><li><strong>非死锁bug</strong><ul><li><strong>违背原子性bug</strong><br> 类似下面的场景,假如Thread1执行 if判断语句后被中断,线程切换到Thread2,共享数据被置为null,再切换到Thread1执行时就会产生null错误的bug. <img src="'+g+'" alt=""><br> 解决方案就是直接再临界区上下加锁. <img src="'+u+'" alt=""></li><li><strong>违背顺序性bug</strong><br> 类似下面的场景,假如Thread1还没初始化完成,就切换到Thread2执行,会产生null错误. <img src="'+s+'" alt=""><br> 如下所示,可以用条件变量解决.<br><img src="'+a+'" alt=""></li></ul></li><li><strong>死锁bug</strong><br> 类似下面的代码,假设Thread1和Thread2先分别获得L1,L2锁,此时Thread1想获取L2,Thread2想获取L1,但都互相被对方占用的状态,双方都不能获取完整的锁,陷入持续的等待中.这种状态即死锁.<br><img src="'+c+'" alt=""><br> 下图展示了死锁状态. <img src="'+i+'" alt=""> 解决方案就是让所有线程按照同样的顺序获取锁,则可预防死锁.</li></ol>',3)]))}const h=n(b,[["render",l]]),m=JSON.parse('{"path":"/ostep-note/2%20%20concurrency/32%20Concurrency%20Bugs.html","title":"32 Concurrency Bugs 并发bug","lang":"zh-CN","frontmatter":{"description":"32 Concurrency Bugs 并发bug 概述: 由于并发的复杂性和不可控性,很容易产生并发bug.并发bug主要分为死锁bug和非死锁bug.非死锁bug又主要有两类,一类是违背原子性bug,一类是违背顺序性bug. 非死锁bug 违背原子性bug 类似下面的场景,假如Thread1执行 if判断语句后被中断,线程切换到Thread2,共享...","head":[["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"32 Concurrency Bugs 并发bug\\",\\"image\\":[\\"\\"],\\"dateModified\\":null,\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"Paper-Dragon\\",\\"url\\":\\"https://github.com/Paper-Dragon\\",\\"email\\":\\"2678885646@qq.com\\"}]}"],["meta",{"property":"og:url","content":"https://www.geekery.cn/ostep-note/2%20%20concurrency/32%20Concurrency%20Bugs.html"}],["meta",{"property":"og:site_name","content":"运维开发绿皮书"}],["meta",{"property":"og:title","content":"32 Concurrency Bugs 并发bug"}],["meta",{"property":"og:description","content":"32 Concurrency Bugs 并发bug 概述: 由于并发的复杂性和不可控性,很容易产生并发bug.并发bug主要分为死锁bug和非死锁bug.非死锁bug又主要有两类,一类是违背原子性bug,一类是违背顺序性bug. 非死锁bug 违背原子性bug 类似下面的场景,假如Thread1执行 if判断语句后被中断,线程切换到Thread2,共享..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}]]},"git":{},"readingTime":{"minutes":1.08,"words":323},"filePathRelative":"ostep-note/2  concurrency/32 Concurrency Bugs.md","excerpt":"\\n<p><strong>概述:</strong><br>\\n由于并发的复杂性和不可控性,很容易产生并发bug.并发bug主要分为死锁bug和非死锁bug.非死锁bug又主要有两类,一类是违背原子性bug,一类是违背顺序性bug.</p>\\n<ol>\\n<li><strong>非死锁bug</strong>\\n<ul>\\n<li><strong>违背原子性bug</strong><br>\\n类似下面的场景,假如Thread1执行 if判断语句后被中断,线程切换到Thread2,共享数据被置为null,再切换到Thread1执行时就会产生null错误的bug.\\n<br>\\n解决方案就是直接再临界区上下加锁.\\n</li>\\n<li><strong>违背顺序性bug</strong><br>\\n类似下面的场景,假如Thread1还没初始化完成,就切换到Thread2执行,会产生null错误.\\n<br>\\n如下所示,可以用条件变量解决.<br>\\n</li>\\n</ul>\\n</li>\\n<li><strong>死锁bug</strong><br>\\n类似下面的代码,假设Thread1和Thread2先分别获得L1,L2锁,此时Thread1想获取L2,Thread2想获取L1,但都互相被对方占用的状态,双方都不能获取完整的锁,陷入持续的等待中.这种状态即死锁.<br>\\n<br>\\n下图展示了死锁状态.\\n\\n解决方案就是让所有线程按照同样的顺序获取锁,则可预防死锁.</li>\\n</ol>","autoDesc":true}');export{h as comp,m as data};
