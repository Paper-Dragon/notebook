import{aq as e,ar as n,aw as o,av as r}from"./app-B6pX3YiM.js";const i={};function p(a,t){return r(),n("div",null,t[0]||(t[0]=[o("<p>22 Swapping Policies 交换策略</p><p><strong>概述:</strong><br> 首先,交换内存到磁盘交换空间的消耗是比较大的,所以有必要尽量减少交换. 一种最有的策略是,将未来最晚访问的页交换,则可以达到缓存未命中率最低,或者说缓存命中率最高.</p><ol><li><p><strong>简单策略: FIFO</strong><br> 先入页先交换,优点是实现简单,缺点就是可能会把频繁访问的页频繁交换出去.</p></li><li><p><strong>随机</strong><br> 优点是实现简单,缺点是缓存命中率页时好时坏.但在循环引用内存分页,需要交换内存的场景下,效果是最好的. 因为循环引用的时候,不管LRU还是FIFO都会把之前的页交换出去,随机则可能交换可能不交换,相比之下,命中率则会高一些.</p></li><li><p><strong>利用历史数据:LRU</strong><br> FIFO和随机都有可能交换出频繁访问的重要的页.LRU基于分页访问频率,交换出不经常访问的分页,保留经常访问的分页. 缺点在于实现复杂,统计访问频次也比较消耗性能.</p></li><li><p><strong>近似LRU</strong><br> 完整的LRU实现比较复杂也比较消耗性能. 近似LRU通过硬件为每个页增加一个使用位,1代表最近被访问,0代表没有被使用. 当需要交换内存时,错做系统通过扫描分页列表,如果使用位是1则不交换并改为0,如果是0则交换.虽然这种方式不如完整的LRU完美,但是性能消耗低,同时可以基于一定的历史信息做交换决策,比一般的没有基于历史信息的策略效果要好.</p></li></ol>",3)]))}const l=e(i,[["render",p],["__file","22 Swapping Policies.html.vue"]]),c=JSON.parse('{"path":"/note-book/OperaSystems/OperatingSystemPrinciple/ostep-note/1virtualization/22%20Swapping%20Policies.html","title":"","lang":"zh-CN","frontmatter":{"description":"22 Swapping Policies 交换策略 概述: 首先,交换内存到磁盘交换空间的消耗是比较大的,所以有必要尽量减少交换. 一种最有的策略是,将未来最晚访问的页交换,则可以达到缓存未命中率最低,或者说缓存命中率最高. 简单策略: FIFO 先入页先交换,优点是实现简单,缺点就是可能会把频繁访问的页频繁交换出去. 随机 优点是实现简单,缺点是缓存...","head":[["meta",{"property":"og:url","content":"https://www.geekery.cn/note-book/OperaSystems/OperatingSystemPrinciple/ostep-note/1virtualization/22%20Swapping%20Policies.html"}],["meta",{"property":"og:site_name","content":"运维开发绿皮书"}],["meta",{"property":"og:description","content":"22 Swapping Policies 交换策略 概述: 首先,交换内存到磁盘交换空间的消耗是比较大的,所以有必要尽量减少交换. 一种最有的策略是,将未来最晚访问的页交换,则可以达到缓存未命中率最低,或者说缓存命中率最高. 简单策略: FIFO 先入页先交换,优点是实现简单,缺点就是可能会把频繁访问的页频繁交换出去. 随机 优点是实现简单,缺点是缓存..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2023-08-13T15:08:38.000Z"}],["meta",{"property":"article:modified_time","content":"2023-08-13T15:08:38.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"\\",\\"image\\":[\\"\\"],\\"dateModified\\":\\"2023-08-13T15:08:38.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"PaperDragon\\",\\"url\\":\\"https://github.com/Paper-Dragon\\",\\"email\\":\\"2678885646@qq.com\\"}]}"]]},"git":{"createdTime":1691939318000,"updatedTime":1691939318000,"contributors":[{"name":"PaperDragon","username":"PaperDragon","email":"2678885646@qq.com","commits":1,"url":"https://github.com/PaperDragon"}]},"readingTime":{"minutes":1.55,"words":466},"filePathRelative":"note-book/OperaSystems/OperatingSystemPrinciple/ostep-note/1virtualization/22 Swapping Policies.md","localizedDate":"2023年8月13日","excerpt":"<p>22 Swapping Policies 交换策略</p>\\n<p><strong>概述:</strong><br>\\n首先,交换内存到磁盘交换空间的消耗是比较大的,所以有必要尽量减少交换. 一种最有的策略是,将未来最晚访问的页交换,则可以达到缓存未命中率最低,或者说缓存命中率最高.</p>\\n<ol>\\n<li>\\n<p><strong>简单策略: FIFO</strong><br>\\n先入页先交换,优点是实现简单,缺点就是可能会把频繁访问的页频繁交换出去.</p>\\n</li>\\n<li>\\n<p><strong>随机</strong><br>\\n优点是实现简单,缺点是缓存命中率页时好时坏.但在循环引用内存分页,需要交换内存的场景下,效果是最好的. 因为循环引用的时候,不管LRU还是FIFO都会把之前的页交换出去,随机则可能交换可能不交换,相比之下,命中率则会高一些.</p>\\n</li>\\n<li>\\n<p><strong>利用历史数据:LRU</strong><br>\\nFIFO和随机都有可能交换出频繁访问的重要的页.LRU基于分页访问频率,交换出不经常访问的分页,保留经常访问的分页. 缺点在于实现复杂,统计访问频次也比较消耗性能.</p>\\n</li>\\n<li>\\n<p><strong>近似LRU</strong><br>\\n完整的LRU实现比较复杂也比较消耗性能. 近似LRU通过硬件为每个页增加一个使用位,1代表最近被访问,0代表没有被使用. 当需要交换内存时,错做系统通过扫描分页列表,如果使用位是1则不交换并改为0,如果是0则交换.虽然这种方式不如完整的LRU完美,但是性能消耗低,同时可以基于一定的历史信息做交换决策,比一般的没有基于历史信息的策略效果要好.</p>\\n</li>\\n</ol>","autoDesc":true}');export{l as comp,c as data};
