import{_ as t}from"./plugin-vue_export-helper-DlAUqK2U.js";import{aj as a,ao as o,am as n}from"./app-b9IBifcg.js";const r="/assets/16918414601881-BdpF83FA.png",p="/assets/16918414620543-dosXBmZc.png",U={};function s(c,e){return n(),a("div",null,e[0]||(e[0]=[o('<h1 id="cpu和内存之间的架构分为两种" tabindex="-1"><a class="header-anchor" href="#cpu和内存之间的架构分为两种"><span>CPU和内存之间的架构分为两种：</span></a></h1><h2 id="_1、uma" tabindex="-1"><a class="header-anchor" href="#_1、uma"><span>1、UMA</span></a></h2><p>UMA全称为 Uniform Memory Access，叫做一致性内存访问</p><p>多个CPU通过同一根总线来访问内存。无论多个CPU是访问内存的不同内存单元还是相同的内存单元，同一时刻，只有一个CPU能够访问内存。</p><p>CPU之间通过总线串行的访问内存，所以会出现访问瓶颈！ <img src="'+r+'" alt="在这里插入图片描述" loading="lazy"></p><h2 id="_2、numa" tabindex="-1"><a class="header-anchor" href="#_2、numa"><span>2、NUMA</span></a></h2><p>Non-Uniform Memory Access ,非一致性内存访问。每个CPU都分配了一块内存，这样的话，多个CPU可以同时并行访问各自的内存，这样的话，读写内存的效率就上来了。</p><p>但是当CPU读取其他CPU的内存的时候，需要通过QPI申请访问，是要慢于直接访问本地内存的。</p><p><img src="'+p+'" alt="在这里插入图片描述" loading="lazy"> UMA和NUMA的使用场景</p><p>如果一个CPU访问的数据量不大，本地内存就足够的话，那么NUMA的优势就可以发挥出来了，各个CPU可以并发的访问自己的内存。</p><p>如果CPU访问的数据量大的话，那么CPU需要频繁的访问其他CPU的内存，QPI的效率是要小于UMA总线的效率。所以NUMA的效率会低于UMA的。</p><h1 id="总结" tabindex="-1"><a class="header-anchor" href="#总结"><span>总结</span></a></h1><p>个人电脑大部分采用UMA，服务器采用NUMA。无论是UMA还是NUMA，对于同一块内存，在同一时间只能由一个CPU访问。</p>',13)]))}const l=t(U,[["render",s],["__file","CPU和内存的架构UMA和NUMA.html.vue"]]),P=JSON.parse('{"path":"/note-book/OperaSystems/CPU%E5%92%8C%E5%86%85%E5%AD%98%E7%9A%84%E6%9E%B6%E6%9E%84UMA%E5%92%8CNUMA.html","title":"CPU和内存之间的架构分为两种：","lang":"zh-CN","frontmatter":{"description":"CPU和内存之间的架构分为两种： 1、UMA UMA全称为 Uniform Memory Access，叫做一致性内存访问 多个CPU通过同一根总线来访问内存。无论多个CPU是访问内存的不同内存单元还是相同的内存单元，同一时刻，只有一个CPU能够访问内存。 CPU之间通过总线串行的访问内存，所以会出现访问瓶颈！ 在这里插入图片描述 2、NUMA Non...","head":[["meta",{"property":"og:url","content":"https://www.geekery.cn/note-book/OperaSystems/CPU%E5%92%8C%E5%86%85%E5%AD%98%E7%9A%84%E6%9E%B6%E6%9E%84UMA%E5%92%8CNUMA.html"}],["meta",{"property":"og:site_name","content":"运维开发绿皮书"}],["meta",{"property":"og:title","content":"CPU和内存之间的架构分为两种："}],["meta",{"property":"og:description","content":"CPU和内存之间的架构分为两种： 1、UMA UMA全称为 Uniform Memory Access，叫做一致性内存访问 多个CPU通过同一根总线来访问内存。无论多个CPU是访问内存的不同内存单元还是相同的内存单元，同一时刻，只有一个CPU能够访问内存。 CPU之间通过总线串行的访问内存，所以会出现访问瓶颈！ 在这里插入图片描述 2、NUMA Non..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2024-03-22T07:42:36.000Z"}],["meta",{"property":"article:modified_time","content":"2024-03-22T07:42:36.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"CPU和内存之间的架构分为两种：\\",\\"image\\":[\\"\\"],\\"dateModified\\":\\"2024-03-22T07:42:36.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"PaperDragon\\",\\"url\\":\\"https://github.com/Paper-Dragon\\",\\"email\\":\\"2678885646@qq.com\\"}]}"]]},"headers":[{"level":2,"title":"1、UMA","slug":"_1、uma","link":"#_1、uma","children":[]},{"level":2,"title":"2、NUMA","slug":"_2、numa","link":"#_2、numa","children":[]}],"git":{"createdTime":1691939318000,"updatedTime":1711093356000,"contributors":[{"name":"PaperDragon-SH","email":"2678885646@qq.com","commits":1}]},"readingTime":{"minutes":1.34,"words":402},"filePathRelative":"note-book/OperaSystems/CPU和内存的架构UMA和NUMA.md","localizedDate":"2023年8月13日","excerpt":"\\n<h2>1、UMA</h2>\\n<p>UMA全称为 Uniform Memory Access，叫做一致性内存访问</p>\\n<p>多个CPU通过同一根总线来访问内存。无论多个CPU是访问内存的不同内存单元还是相同的内存单元，同一时刻，只有一个CPU能够访问内存。</p>\\n<p>CPU之间通过总线串行的访问内存，所以会出现访问瓶颈！\\n</p>\\n<h2>2、NUMA</h2>\\n<p>Non-Uniform Memory Access ,非一致性内存访问。每个CPU都分配了一块内存，这样的话，多个CPU可以同时并行访问各自的内存，这样的话，读写内存的效率就上来了。</p>\\n<p>但是当CPU读取其他CPU的内存的时候，需要通过QPI申请访问，是要慢于直接访问本地内存的。</p>","autoDesc":true}');export{l as comp,P as data};
