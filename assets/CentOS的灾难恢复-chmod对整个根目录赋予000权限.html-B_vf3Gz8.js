import{ah as e,ai as i,ar as a,am as n}from"./app-jvJXBecG.js";const t={};function h(d,s){return n(),i("div",null,s[0]||(s[0]=[a(`<h1 id="centos的灾难恢复-chmod对整个根目录赋予000权限" tabindex="-1"><a class="header-anchor" href="#centos的灾难恢复-chmod对整个根目录赋予000权限"><span>CentOS的灾难恢复-chmod对整个根目录赋予000权限</span></a></h1><blockquote><p><strong>每日一个跑路小命令，没准哪天能用上呢【滑稽】，切勿在生产环境使用，切勿在生产环境使用，切勿在生产环境使用</strong></p></blockquote><p>在Linux系统管理中，错误地对根目录（<code>/</code>）递归执行 <code>chmod 000</code> 命令，会引发严重的系统故障。本文将详细介绍在CentOS系统上，如何从这种极端的文件权限故障中恢复系统。</p><h2 id="进入救援模式修复系统" tabindex="-1"><a class="header-anchor" href="#进入救援模式修复系统"><span>进入救援模式修复系统</span></a></h2><p>由于操作系统本身已无法启动，我们必须借助外部的、独立的运行环境来进行修复。方法是使用CentOS安装镜像（ISO）提供的救援模式（Rescue Mode）。</p><p>首先，将系统安装镜像挂载到服务器，并设置从该镜像启动。</p><ol><li>在系统引导菜单中，选择 <code>Troubleshooting</code>（故障排查）选项。</li><li>接着，在下一级菜单中选择 <code>Rescue a CentOS system</code>（救援一个CentOS系统）。</li></ol><p>救援程序启动后，会扫描硬盘并尝试定位已安装的系统。随后，程序会提供一个交互式菜单，包含几个挂载选项，此处的选择非常关键。</p><div class="language-bash line-numbers-mode" data-highlighter="shiki" data-ext="bash" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code class="language-bash"><span class="line"><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">1</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">) Continue</span></span>
<span class="line"><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">2</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">) Read-only mount</span></span>
<span class="line"><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">3</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">) Skip to shell</span></span>
<span class="line"><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">4</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">) Quit (</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">reboot</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">)</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ul><li><strong>选项 1 (Continue)</strong>：该选项会尝试以读写模式挂载系统分区并自动执行 <code>chroot</code>。<strong>此操作将会失败</strong>，因为目标系统内的 <code>/bin/bash</code> 等所有基础命令均无执行权限，<code>chroot</code> 无法成功建立环境。</li><li><strong>选项 2 (Read-only mount)</strong>：该选项以 <strong>只读模式</strong> 将系统分区挂载到 <code>/mnt/sysroot</code> 目录，且不执行 <code>chroot</code>。<strong>这是正确的选择</strong>，它使我们能够安全地访问到损坏的系统文件，为后续修复做准备。</li></ul><p>请选择选项 <code>2</code> 并按回车，系统将进入救援模式的命令行Shell。</p><h2 id="恢复文件系统权限" tabindex="-1"><a class="header-anchor" href="#恢复文件系统权限"><span>恢复文件系统权限</span></a></h2><p>进入救援环境后，我们的核心任务是逐步恢复系统文件的正确权限。整个过程分为三个主要步骤。</p><h3 id="第一步-重新挂载为读写模式" tabindex="-1"><a class="header-anchor" href="#第一步-重新挂载为读写模式"><span>第一步：重新挂载为读写模式</span></a></h3><p>救援模式默认以只读方式挂载分区以防止误操作。要进行修复，我们首先需要获取写入权限。执行以下命令，将分区重新挂载为读写（rw）模式：</p><div class="language-bash line-numbers-mode" data-highlighter="shiki" data-ext="bash" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code class="language-bash"><span class="line"><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">mount</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;"> -o</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> remount,rw</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> /mnt/sysroot</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><p>可以通过 <code>mount | grep sysroot</code> 命令检查挂载状态，确认其已从 <code>ro</code>（只读）变为 <code>rw</code>（读写）。</p><h3 id="第二步-临时授予所有权限" tabindex="-1"><a class="header-anchor" href="#第二步-临时授予所有权限"><span>第二步：临时授予所有权限</span></a></h3><p>当前，我们仍无法 <code>chroot</code> 到 <code>/mnt/sysroot</code>，因为目标环境内的命令依然没有执行权限。为了解决这个问题，需要一个临时的、直接的措施来恢复文件的可执行性。</p><div class="language-bash line-numbers-mode" data-highlighter="shiki" data-ext="bash" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code class="language-bash"><span class="line"><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">chmod</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;"> -R</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;"> 777</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> /mnt/sysroot</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><p>此命令将原系统根分区下的所有文件和目录权限设置为 <code>777</code>，确保了所有内容都可读、可写、可执行。虽然这会造成暂时的权限混乱，但它是执行后续修复步骤的必要前提。</p><h3 id="第三步-切换环境并使用rpm数据库恢复" tabindex="-1"><a class="header-anchor" href="#第三步-切换环境并使用rpm数据库恢复"><span>第三步：切换环境并使用RPM数据库恢复</span></a></h3><p>在所有文件都具备执行权限后，我们便可以成功地 <code>chroot</code> 到原系统环境中，进行更精确的权限修复。</p><div class="language-bash line-numbers-mode" data-highlighter="shiki" data-ext="bash" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code class="language-bash"><span class="line"><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">chroot</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> /mnt/sysroot</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><p>执行此命令后，命令行提示符会改变，表示当前操作环境已切换到原系统的根目录。</p><p>此时，问题已经从“如何从 <code>000</code> 权限恢复”转变为“如何从 <code>777</code> 的混乱权限恢复到系统默认状态”。幸运的是，RPM包管理器在其数据库中保存了所有已安装软件包的元数据，包括每个文件的初始权限。我们可以利用这一点来恢复绝大多数文件的权限。</p><p>执行以下命令，让RPM遍历所有软件包并重置其文件权限：</p><div class="language-bash line-numbers-mode" data-highlighter="shiki" data-ext="bash" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code class="language-bash"><span class="line"><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">rpm</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;"> -qa</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> | </span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">xargs</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> rpm</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;"> --setperms</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><ul><li><code>rpm -qa</code> 用于查询所有已安装的软件包名称。</li><li><code>xargs</code> 将查询结果传递给 <code>rpm --setperms</code> 命令，该命令会根据RPM数据库中的记录，为每个软件包中的文件恢复其默认权限。</li></ul><p>这个过程可能需要一些时间。完成后，系统中绝大部分文件的权限都已恢复正常。</p><h2 id="手动修复特殊文件权限" tabindex="-1"><a class="header-anchor" href="#手动修复特殊文件权限"><span>手动修复特殊文件权限</span></a></h2><p>完成上述步骤后，虽然系统核心组件的权限已恢复，但整个修复工作尚未结束。<code>rpm --setperms</code> 命令只能恢复由RPM软件包自身包含的文件的权限。对于那些在软件安装后由服务自动生成的文件（如SSH主机密钥）、用户自行创建的数据、或从源码编译安装的程序，它们的权限仍然是之前设置的 <code>777</code>。我们需要手动检查并修复这些特殊文件，其中SSH服务是需要优先处理的最典型例子。</p><p>系统重启后，请使用控制台登录并检查SSH服务的状态：</p><div class="language-bash line-numbers-mode" data-highlighter="shiki" data-ext="bash" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code class="language-bash"><span class="line"><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">systemctl</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> status</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> sshd</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><p>通常会发现服务启动失败。要定位具体原因，可以查看服务日志：</p><div class="language-bash line-numbers-mode" data-highlighter="shiki" data-ext="bash" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code class="language-bash"><span class="line"><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">journalctl</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;"> -u</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> sshd</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><p>日志中会出现类似 <code>Permissions ... for &#39;/etc/ssh/ssh_host_..._key&#39; are too open</code> 的关键错误信息。这是因为SSHD守护进程出于安全考虑，会检查其密钥文件的权限。如果发现私钥文件（例如主机密钥）的权限过于开放，它会拒绝加载这些密钥，从而导致服务启动失败。</p><p>修复方法是手动为SSH的配置文件和密钥设置严格的权限。一个安全有效的做法是：</p><div class="language-bash line-numbers-mode" data-highlighter="shiki" data-ext="bash" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code class="language-bash"><span class="line"><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">chmod</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;"> -R</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;"> 600</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> /etc/ssh/</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><p>该命令将 <code>/etc/ssh/</code> 目录及其下所有文件的权限设置为 <code>600</code>，即仅文件所有者（root）拥有读写权限，符合SSH的安全要求。</p><p>完成权限修改后，重新启动并检查SSH服务：</p><div class="language-bash line-numbers-mode" data-highlighter="shiki" data-ext="bash" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code class="language-bash"><span class="line"><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">systemctl</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> restart</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> sshd</span></span>
<span class="line"><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">systemctl</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> status</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> sshd</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div></div></div><p>此时，服务状态应显示为 <code>active (running)</code>。</p><p>修复SSH后，建议举一反三，检查系统中其他关键服务的状态，例如Web服务器（httpd, nginx）、数据库（MariaDB）等。如果发现有服务启动失败，遵循同样的方法，通过 <code>journalctl -u &lt;服务名&gt;</code> 查看日志，定位因权限问题导致的错误，并进行手动修复。此外，也应检查 <code>/home</code>、<code>/srv</code>、<code>/opt</code> 等目录下用户数据的权限是否需要调整。</p>`,44)]))}const r=e(t,[["render",h]]),o=JSON.parse('{"path":"/note-book/OperaSystems/RedHatEnterpriseLinux/CentOS%E7%9A%84%E7%81%BE%E9%9A%BE%E6%81%A2%E5%A4%8D-chmod%E5%AF%B9%E6%95%B4%E4%B8%AA%E6%A0%B9%E7%9B%AE%E5%BD%95%E8%B5%8B%E4%BA%88000%E6%9D%83%E9%99%90.html","title":"CentOS的灾难恢复-chmod对整个根目录赋予000权限","lang":"zh-CN","frontmatter":{"description":"CentOS的灾难恢复-chmod对整个根目录赋予000权限 每日一个跑路小命令，没准哪天能用上呢【滑稽】，切勿在生产环境使用，切勿在生产环境使用，切勿在生产环境使用 在Linux系统管理中，错误地对根目录（/）递归执行 chmod 000 命令，会引发严重的系统故障。本文将详细介绍在CentOS系统上，如何从这种极端的文件权限故障中恢复系统。 进入救...","head":[["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"CentOS的灾难恢复-chmod对整个根目录赋予000权限\\",\\"image\\":[\\"\\"],\\"dateModified\\":\\"2025-07-20T07:02:12.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"Paper-Dragon\\",\\"url\\":\\"https://github.com/Paper-Dragon\\",\\"email\\":\\"2678885646@qq.com\\"}]}"],["meta",{"property":"og:url","content":"https://www.geekery.cn/note-book/OperaSystems/RedHatEnterpriseLinux/CentOS%E7%9A%84%E7%81%BE%E9%9A%BE%E6%81%A2%E5%A4%8D-chmod%E5%AF%B9%E6%95%B4%E4%B8%AA%E6%A0%B9%E7%9B%AE%E5%BD%95%E8%B5%8B%E4%BA%88000%E6%9D%83%E9%99%90.html"}],["meta",{"property":"og:site_name","content":"运维开发绿皮书"}],["meta",{"property":"og:title","content":"CentOS的灾难恢复-chmod对整个根目录赋予000权限"}],["meta",{"property":"og:description","content":"CentOS的灾难恢复-chmod对整个根目录赋予000权限 每日一个跑路小命令，没准哪天能用上呢【滑稽】，切勿在生产环境使用，切勿在生产环境使用，切勿在生产环境使用 在Linux系统管理中，错误地对根目录（/）递归执行 chmod 000 命令，会引发严重的系统故障。本文将详细介绍在CentOS系统上，如何从这种极端的文件权限故障中恢复系统。 进入救..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2025-07-20T07:02:12.000Z"}],["meta",{"property":"article:modified_time","content":"2025-07-20T07:02:12.000Z"}]]},"git":{"createdTime":1717999346000,"updatedTime":1752994932000,"contributors":[{"name":"Paper-Dragon","username":"Paper-Dragon","email":"2678885646@qq.com","commits":2,"url":"https://github.com/Paper-Dragon"}],"changelog":[{"hash":"2940f1e84fdfc4069f51949d7b2f05664f5559d9","time":1752994932000,"email":"2678885646@qq.com","author":"Paper-Dragon","message":"CentOS的灾难恢复-chmod对整个根目录赋予000权限"},{"hash":"17aaa97cee4857b9203247941cf84fdf21c66e97","time":1717999346000,"email":"2678885646@qq.com","author":"Paper-Dragon","message":"random password"}]},"readingTime":{"minutes":5.4,"words":1619},"filePathRelative":"note-book/OperaSystems/RedHatEnterpriseLinux/CentOS的灾难恢复-chmod对整个根目录赋予000权限.md","excerpt":"\\n<blockquote>\\n<p><strong>每日一个跑路小命令，没准哪天能用上呢【滑稽】，切勿在生产环境使用，切勿在生产环境使用，切勿在生产环境使用</strong></p>\\n</blockquote>\\n<p>在Linux系统管理中，错误地对根目录（<code>/</code>）递归执行 <code>chmod 000</code> 命令，会引发严重的系统故障。本文将详细介绍在CentOS系统上，如何从这种极端的文件权限故障中恢复系统。</p>\\n<h2>进入救援模式修复系统</h2>\\n<p>由于操作系统本身已无法启动，我们必须借助外部的、独立的运行环境来进行修复。方法是使用CentOS安装镜像（ISO）提供的救援模式（Rescue Mode）。</p>","autoDesc":true}');export{r as comp,o as data};
